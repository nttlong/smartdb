!function (g) { g.fn.drag = function (t, e, a) { var n = "string" == typeof t ? t : "", r = g.isFunction(t) ? t : g.isFunction(e) ? e : null; return 0 !== n.indexOf("drag") && (n = "drag" + n), a = (t == r ? e : a) || {}, r ? this.on(n, a, r) : this.trigger(n) }; var h = g.event, n = h.special, f = n.drag = { defaults: { which: 1, distance: 0, not: ":input", handle: null, relative: !1, drop: !0, click: !1 }, datakey: "dragdata", noBubble: !0, add: function (t) { var a = g.data(this, f.datakey), n = t.data || {}; a.related += 1, g.each(f.defaults, function (t, e) { void 0 !== n[t] && (a[t] = n[t]) }) }, remove: function () { g.data(this, f.datakey).related -= 1 }, setup: function () { if (!g.data(this, f.datakey)) { var t = g.extend({ related: 0 }, f.defaults); g.data(this, f.datakey, t), h.add(this, "touchstart mousedown", f.init, t), this.attachEvent && this.attachEvent("ondragstart", f.dontstart) } }, teardown: function () { (g.data(this, f.datakey) || {}).related || (g.removeData(this, f.datakey), h.remove(this, "touchstart mousedown", f.init), f.textselect(!0), this.detachEvent && this.detachEvent("ondragstart", f.dontstart)) }, init: function (t) { if (!f.touched) { var e, a = t.data; if (!(0 != t.which && 0 < a.which && t.which != a.which) && !g(t.target).is(a.not) && (!a.handle || g(t.target).closest(a.handle, t.currentTarget).length) && (f.touched = "touchstart" == t.type ? this : null, a.propagates = 1, a.mousedown = this, a.interactions = [f.interaction(this, a)], a.target = t.target, a.pageX = t.pageX, a.pageY = t.pageY, a.dragging = null, e = f.hijack(t, "draginit", a), a.propagates)) return (e = f.flatten(e)) && e.length && (a.interactions = [], g.each(e, function () { a.interactions.push(f.interaction(this, a)) })), a.propagates = a.interactions.length, !1 !== a.drop && n.drop && n.drop.handler(t, a), f.textselect(!1), f.touched ? h.add(f.touched, "touchmove touchend", f.handler, a) : h.add(document, "mousemove mouseup", f.handler, a), !(!f.touched || a.live) && void 0 } }, interaction: function (t, e) { var a = t && t.ownerDocument && g(t)[e.relative ? "position" : "offset"]() || { top: 0, left: 0 }; return { drag: t, callback: new f.callback, droppable: [], offset: a } }, handler: function (t) { var e = t.data; switch (t.type) { case !e.dragging && "touchmove": t.preventDefault(); case !e.dragging && "mousemove": if (Math.pow(t.pageX - e.pageX, 2) + Math.pow(t.pageY - e.pageY, 2) < Math.pow(e.distance, 2)) break; t.target = e.target, f.hijack(t, "dragstart", e), e.propagates && (e.dragging = !0); case "touchmove": t.preventDefault(); case "mousemove": if (e.dragging) { if (f.hijack(t, "drag", e), e.propagates) { !1 !== e.drop && n.drop && n.drop.handler(t, e); break } t.type = "mouseup" } case "touchend": case "mouseup": default: f.touched ? h.remove(f.touched, "touchmove touchend", f.handler) : h.remove(document, "mousemove mouseup", f.handler), e.dragging && (!1 !== e.drop && n.drop && n.drop.handler(t, e), f.hijack(t, "dragend", e)), f.textselect(!0), !1 === e.click && e.dragging && g.data(e.mousedown, "suppress.click", (new Date).getTime() + 5), e.dragging = f.touched = !1 } }, hijack: function (a, n, r, t, e) { if (r) { var o, i, d, s = { event: a.originalEvent, type: a.type }, c = n.indexOf("drop") ? "drag" : "drop", l = t || 0, p = isNaN(t) ? r.interactions.length : t; a.type = n; function u() { } a.originalEvent = new jQuery.Event(s.event, { preventDefault: u, stopPropagation: u, stopImmediatePropagation: u }), r.results = []; do { if (i = r.interactions[l]) { if ("dragend" !== n && i.cancelled) continue; d = f.properties(a, r, i), i.results = [], g(e || i[c] || r.droppable).each(function (t, e) { if (d.target = e, !(a.isPropagationStopped = function () { return !1 }) === (o = e ? h.dispatch.call(e, a, d) : null) ? ("drag" == c && (i.cancelled = !0, r.propagates -= 1), "drop" == n && (i[c][t] = null)) : "dropinit" == n && i.droppable.push(f.element(o) || e), "dragstart" == n && (i.proxy = g(f.element(o) || i.drag)[0]), i.results.push(o), delete a.result, "dropinit" !== n) return o }), r.results[l] = f.flatten(i.results), "dropinit" == n && (i.droppable = f.flatten(i.droppable)), "dragstart" != n || i.cancelled || d.update() } } while (++l < p); return a.type = s.type, a.originalEvent = s.event, f.flatten(r.results) } }, properties: function (t, e, a) { var n = a.callback; return n.drag = a.drag, n.proxy = a.proxy || a.drag, n.startX = e.pageX, n.startY = e.pageY, n.deltaX = t.pageX - e.pageX, n.deltaY = t.pageY - e.pageY, n.originalX = a.offset.left, n.originalY = a.offset.top, n.offsetX = n.originalX + n.deltaX, n.offsetY = n.originalY + n.deltaY, n.drop = f.flatten((a.drop || []).slice()), n.available = f.flatten((a.droppable || []).slice()), n }, element: function (t) { if (t && (t.jquery || 1 == t.nodeType)) return t }, flatten: function (t) { return g.map(t, function (t) { return t && t.jquery ? g.makeArray(t) : t && t.length ? f.flatten(t) : t }) }, textselect: function (t) { g(document)[t ? "off" : "on"]("selectstart", f.dontstart).css("MozUserSelect", t ? "" : "none"), document.unselectable = t ? "off" : "on" }, dontstart: function () { return !1 }, callback: function () { } }; f.callback.prototype = { update: function () { n.drop && this.available.length && g.each(this.available, function (t) { n.drop.locate(this, t) }) } }; var e = h.dispatch; h.dispatch = function (t) { if (!(0 < g.data(this, "suppress." + t.type) - (new Date).getTime())) return e.apply(this, arguments); g.removeData(this, "suppress." + t.type) }, n.draginit = n.dragstart = n.dragend = f }(jQuery);
/*-----------------------------------*/
!function () { function s() { var t = !1, i = !1; this.stopPropagation = function () { t = !0 }, this.isPropagationStopped = function () { return t }, this.stopImmediatePropagation = function () { i = !0 }, this.isImmediatePropagationStopped = function () { return i } } function t() { this.__nonDataRow = !0 } function i() { this.__group = !0, this.level = 0, this.count = 0, this.value = null, this.title = null, this.collapsed = !1, this.selectChecked = !1, this.totals = null, this.rows = [], this.groups = null, this.groupingKey = null } function n() { this.__groupTotals = !0, this.group = null, this.initialized = !1 } function o() { var i = null; this.isActive = function (t) { return t ? i === t : null !== i }, this.activate = function (t) { if (t !== i) { if (null !== i) throw new Error("SlickGrid.EditorLock.activate: an editController is still active, can't activate another editController"); if (!t.commitCurrentEdit) throw new Error("SlickGrid.EditorLock.activate: editController must implement .commitCurrentEdit()"); if (!t.cancelCurrentEdit) throw new Error("SlickGrid.EditorLock.activate: editController must implement .cancelCurrentEdit()"); i = t } }, this.deactivate = function (t) { if (i !== t) throw new Error("SlickGrid.EditorLock.deactivate: specified editController is not the currently active one"); i = null }, this.commitCurrentEdit = function () { return !i || i.commitCurrentEdit() }, this.cancelCurrentEdit = function () { return !i || i.cancelCurrentEdit() } } jQuery.extend(!0, window, { Slick: { Event: function () { var r = []; this.subscribe = function (t) { r.push(t) }, this.unsubscribe = function (t) { for (var i = r.length - 1; 0 <= i; i--)r[i] === t && r.splice(i, 1) }, this.notify = function (t, i, n) { var o; i = i || new s, n = n || this; for (var e = 0; e < r.length && !i.isPropagationStopped() && !i.isImmediatePropagationStopped(); e++)o = r[e].call(n, i, t); return o } }, EventData: s, EventHandler: function () { var o = []; this.subscribe = function (t, i) { return o.push({ event: t, handler: i }), t.subscribe(i), this }, this.unsubscribe = function (t, i) { for (var n = o.length; n--;)if (o[n].event === t && o[n].handler === i) return o.splice(n, 1), void t.unsubscribe(i); return this }, this.unsubscribeAll = function () { for (var t = o.length; t--;)o[t].event.unsubscribe(o[t].handler); return o = [], this } }, Range: function (t, i, n, o) { void 0 === n && void 0 === o && (n = t, o = i); this.fromRow = Math.min(t, n), this.fromCell = Math.min(i, o), this.toRow = Math.max(t, n), this.toCell = Math.max(i, o), this.isSingleRow = function () { return this.fromRow == this.toRow }, this.isSingleCell = function () { return this.fromRow == this.toRow && this.fromCell == this.toCell }, this.contains = function (t, i) { return t >= this.fromRow && t <= this.toRow && i >= this.fromCell && i <= this.toCell }, this.toString = function () { return this.isSingleCell() ? "(" + this.fromRow + ":" + this.fromCell + ")" : "(" + this.fromRow + ":" + this.fromCell + " - " + this.toRow + ":" + this.toCell + ")" } }, NonDataRow: t, Group: i, GroupTotals: n, EditorLock: o, GlobalEditorLock: new o, keyCode: { BACKSPACE: 8, DELETE: 46, DOWN: 40, END: 35, ENTER: 13, ESCAPE: 27, HOME: 36, INSERT: 45, LEFT: 37, PAGE_DOWN: 34, PAGE_UP: 33, RIGHT: 39, TAB: 9, UP: 38 }, preClickClassName: "slick-edit-preclick" } }), (i.prototype = new t).equals = function (t) { return this.value === t.value && this.count === t.count && this.collapsed === t.collapsed && this.title === t.title }, n.prototype = new t }();
/*--------------------------------------------------*/
if ("undefined" == typeof jQuery) throw new Error("SlickGrid requires jquery module to be loaded"); if (!jQuery.fn.drag) throw new Error("SlickGrid requires jquery.event.drag module to be loaded"); if ("undefined" == typeof Slick) throw new Error("slick.core.js not loaded"); !function ($) { var scrollbarDimensions, maxSupportedCssHeight; function SlickGrid(container, data, columns, options) { var defaults = { explicitInitialization: !1, rowHeight: 36, defaultColumnWidth: 80, enableAddRow: !1, leaveSpaceForNewRows: !1, editable: !1, autoEdit: !0, enableCellNavigation: !0, enableColumnReorder: !0, asyncEditorLoading: !1, asyncEditorLoadDelay: 100, forceFitColumns: !1, enableAsyncPostRender: !1, asyncPostRenderDelay: 50, enableAsyncPostRenderCleanup: !1, asyncPostRenderCleanupDelay: 40, autoHeight: !1, editorLock: Slick.GlobalEditorLock, showHeaderRow: !1, headerRowHeight: 25, createFooterRow: !1, showFooterRow: !1, footerRowHeight: 25, createPreHeaderPanel: !1, showPreHeaderPanel: !1, preHeaderPanelHeight: 25, showTopPanel: !1, topPanelHeight: 25, formatterFactory: null, editorFactory: null, cellFlashingCssClass: "flashing", selectedCellCssClass: "selected", multiSelect: !0, enableTextSelectionOnCells: !1, dataItemColumnValueExtractor: null, fullWidthRows: !1, multiColumnSort: !1, numberedMultiColumnSort: !1, tristateMultiColumnSort: !1, defaultFormatter: defaultFormatter, forceSyncScrolling: !1, addNewRowCssClass: "new-row", preserveCopiedSelectionOnPaste: !1, showCellSelection: !0, viewportClass: null }, columnDefaults = { name: "", resizable: !0, sortable: !1, minWidth: 30, rerenderOnResize: !1, headerCssClass: null, defaultSortAsc: !0, focusable: !0, selectable: !0 }, th, h, ph, n, cj, page = 0, offset = 0, vScrollDir = 1, initialized = !1, $container, uid = "slickgrid_" + Math.round(1e6 * Math.random()), self = this, $focusSink, $focusSink2, $headerScroller, $headers, $headerRow, $headerRowScroller, $headerRowSpacer, $footerRow, $footerRowScroller, $footerRowSpacer, $preHeaderPanel, $preHeaderPanelScroller, $preHeaderPanelSpacer, $topPanelScroller, $topPanel, $viewport, $canvas, $style, $boundAncestors, stylesheet, columnCssRulesL, columnCssRulesR, viewportH, viewportW, canvasWidth, viewportHasHScroll, viewportHasVScroll, headerColumnWidthDiff = 0, headerColumnHeightDiff = 0, cellWidthDiff = 0, cellHeightDiff = 0, jQueryNewWidthBehaviour = !1, absoluteColumnMinWidth, sortIndicatorCssClass = "slick-sort-indicator", tabbingDirection = 1, activePosX, activeRow, activeCell, activeCellNode = null, currentEditor = null, serializedEditorValue, editController, rowsCache = {}, renderedRows = 0, numVisibleRows, prevScrollTop = 0, scrollTop = 0, lastRenderedScrollTop = 0, lastRenderedScrollLeft = 0, prevScrollLeft = 0, scrollLeft = 0, selectionModel, selectedRows = [], plugins = [], cellCssClasses = {}, columnsById = {}, sortColumns = [], columnPosLeft = [], columnPosRight = [], pagingActive = !1, pagingIsLastPage = !1, h_editorLoader = null, h_render = null, h_postrender = null, h_postrenderCleanup = null, postProcessedRows = {}, postProcessToRow = null, postProcessFromRow = null, postProcessedCleanupQueue = [], postProcessgroupId = 0, counter_rows_rendered = 0, counter_rows_removed = 0, rowNodeFromLastMouseWheelEvent, zombieRowNodeFromLastMouseWheelEvent, zombieRowCacheFromLastMouseWheelEvent, zombieRowPostProcessedFromLastMouseWheelEvent, cssShow = { position: "absolute", visibility: "hidden", display: "block" }, $hiddenParents, oldProps = [], columnResizeDragging = !1; function init() { if (($container = container instanceof jQuery ? container : $(container)).length < 1) throw new Error("SlickGrid requires a valid container, " + container + " does not exist in the DOM."); cacheCssForHiddenInit(), maxSupportedCssHeight = maxSupportedCssHeight || getMaxSupportedCssHeight(), options = $.extend({}, defaults, options), validateAndEnforceOptions(), columnDefaults.width = options.defaultColumnWidth, columnsById = {}; for (var e = 0; e < columns.length; e++) { var o = columns[e] = $.extend({}, columnDefaults, columns[e]); columnsById[o.id] = e, o.minWidth && o.width < o.minWidth && (o.width = o.minWidth), o.maxWidth && o.width > o.maxWidth && (o.width = o.maxWidth) } if (options.enableColumnReorder && !$.fn.sortable) throw new Error("SlickGrid's 'enableColumnReorder = true' option requires jquery-ui.sortable module to be loaded"); editController = { commitCurrentEdit: commitCurrentEdit, cancelCurrentEdit: cancelCurrentEdit }, $container.empty().css("overflow", "hidden").css("outline", 0).addClass(uid).addClass("ui-widget"), /relative|absolute|fixed/.test($container.css("position")) || $container.css("position", "relative"), $focusSink = $("<div tabIndex='0' hideFocus style='position:fixed;width:0;height:0;top:0;left:0;outline:0;'></div>").appendTo($container), options.createPreHeaderPanel && ($preHeaderPanelScroller = $("<div class='slick-preheader-panel ui-state-default' style='overflow:hidden;position:relative;' />").appendTo($container), $preHeaderPanel = $("<div />").appendTo($preHeaderPanelScroller), $preHeaderPanelSpacer = $("<div style='display:block;height:1px;position:absolute;top:0;left:0;'></div>").appendTo($preHeaderPanelScroller), options.showPreHeaderPanel || $preHeaderPanelScroller.hide()), $headerScroller = $("<div class='slick-header ui-state-default' />").appendTo($container), $headers = $("<div class='slick-header-columns' style='left:-1000px' />").appendTo($headerScroller), $headerRowScroller = $("<div class='slick-headerrow ui-state-default' />").appendTo($container), $headerRow = $("<div class='slick-headerrow-columns' />").appendTo($headerRowScroller), $headerRowSpacer = $("<div style='display:block;height:1px;position:absolute;top:0;left:0;'></div>").appendTo($headerRowScroller), $topPanelScroller = $("<div class='slick-top-panel-scroller ui-state-default' />").appendTo($container), $topPanel = $("<div class='slick-top-panel' style='width:10000px' />").appendTo($topPanelScroller), options.showTopPanel || $topPanelScroller.hide(), options.showHeaderRow || $headerRowScroller.hide(), ($viewport = $("<div class='slick-viewport' style='width:100%;overflow:auto;outline:0;position:relative;;'>").appendTo($container)).css("overflow-y", options.autoHeight ? "hidden" : "auto"), options.viewportClass && $viewport.toggleClass(options.viewportClass, !0), $canvas = $("<div class='grid-canvas' />").appendTo($viewport), scrollbarDimensions = scrollbarDimensions || measureScrollbar(), $preHeaderPanelSpacer && $preHeaderPanelSpacer.css("width", getCanvasWidth() + scrollbarDimensions.width + "px"), $headers.width(getHeadersWidth()), $headerRowSpacer.css("width", getCanvasWidth() + scrollbarDimensions.width + "px"), options.createFooterRow && ($footerRowScroller = $("<div class='slick-footerrow ui-state-default' />").appendTo($container), $footerRow = $("<div class='slick-footerrow-columns' />").appendTo($footerRowScroller), $footerRowSpacer = $("<div style='display:block;height:1px;position:absolute;top:0;left:0;'></div>").css("width", getCanvasWidth() + scrollbarDimensions.width + "px").appendTo($footerRowScroller), options.showFooterRow || $footerRowScroller.hide()), options.numberedMultiColumnSort && (sortIndicatorCssClass = "slick-sort-indicator-numbered"), $focusSink2 = $focusSink.clone().appendTo($container), options.explicitInitialization || finishInitialization() } function finishInitialization() { initialized || (initialized = !0, viewportW = parseFloat($.css($container[0], "width", !0)), measureCellPaddingAndBorder(), disableSelection($headers), options.enableTextSelectionOnCells || $viewport.on("selectstart.ui", function (e) { return $(e.target).is("input,textarea") }), updateColumnCaches(), createColumnHeaders(), setupColumnSort(), createCssRules(), resizeCanvas(), bindAncestorScrollEvents(), $container.on("resize.slickgrid", resizeCanvas), $viewport.on("scroll", handleScroll), $headerScroller.on("scroll", handleHeaderScroll).on("contextmenu", handleHeaderContextMenu).on("click", handleHeaderClick).on("mouseenter", ".slick-header-column", handleHeaderMouseEnter).on("mouseleave", ".slick-header-column", handleHeaderMouseLeave), $headerRowScroller.on("scroll", handleHeaderRowScroll), options.createFooterRow && $footerRowScroller.on("scroll", handleFooterRowScroll), options.createPreHeaderPanel && $preHeaderPanelScroller.on("scroll", handlePreHeaderPanelScroll), $focusSink.add($focusSink2).on("keydown", handleKeyDown), $canvas.on("keydown", handleKeyDown).on("click", handleClick).on("dblclick", handleDblClick).on("contextmenu", handleContextMenu).on("draginit", handleDragInit).on("dragstart", { distance: 3 }, handleDragStart).on("drag", handleDrag).on("dragend", handleDragEnd).on("mouseenter", ".slick-cell", handleMouseEnter).on("mouseleave", ".slick-cell", handleMouseLeave), navigator.userAgent.toLowerCase().match(/webkit/) && navigator.userAgent.toLowerCase().match(/macintosh/) && $canvas.on("mousewheel", handleMouseWheel), restoreCssFromHiddenInit()) } function cacheCssForHiddenInit() { ($hiddenParents = $container.parents().addBack().not(":visible")).each(function () { var e = {}; for (var o in cssShow) e[o] = this.style[o], this.style[o] = cssShow[o]; oldProps.push(e) }) } function restoreCssFromHiddenInit() { $hiddenParents.each(function (e) { var o = oldProps[e]; for (var t in cssShow) this.style[t] = o[t] }) } function registerPlugin(e) { plugins.unshift(e), e.init(self) } function unregisterPlugin(e) { for (var o = plugins.length; 0 <= o; o--)if (plugins[o] === e) { plugins[o].destroy && plugins[o].destroy(), plugins.splice(o, 1); break } } function setSelectionModel(e) { selectionModel && (selectionModel.onSelectedRangesChanged.unsubscribe(handleSelectedRangesChanged), selectionModel.destroy && selectionModel.destroy()), (selectionModel = e) && (selectionModel.init(self), selectionModel.onSelectedRangesChanged.subscribe(handleSelectedRangesChanged)) } function getSelectionModel() { return selectionModel } function getCanvasNode() { return $canvas[0] } function measureScrollbar() { var e = $('<div class="' + $(".slick-viewport")[0].className + '" style="position:absolute; top:-10000px; left:-10000px; overflow:auto; width:100px; height:100px;"></div>').appendTo($(".slick-viewport")), o = $('<div style="width:200px; height:200px; overflow:auto;"></div>').appendTo(e), t = { width: e[0].offsetWidth - e[0].clientWidth, height: e[0].offsetHeight - e[0].clientHeight }; return o.remove(), e.remove(), t } function getColumnTotalWidth(e) { for (var o = 0, t = 0, l = columns.length; t < l; t++) { o += columns[t].width } return e && (o += scrollbarDimensions.width), o } function getHeadersWidth() { var e = getColumnTotalWidth(!options.autoHeight); return Math.max(e, viewportW) + 1e3 } function getCanvasWidth() { for (var e = viewportHasVScroll ? viewportW - scrollbarDimensions.width : viewportW, o = 0, t = columns.length; t--;)o += columns[t].width; return options.fullWidthRows ? Math.max(o, e) : o } function updateCanvasWidth(e) { var o = canvasWidth; (canvasWidth = getCanvasWidth()) != o && ($canvas.width(canvasWidth), $headerRow.width(canvasWidth), options.createFooterRow && $footerRow.width(canvasWidth), options.createPreHeaderPanel && $preHeaderPanel.width(canvasWidth), $headers.width(getHeadersWidth()), viewportHasHScroll = canvasWidth > viewportW - scrollbarDimensions.width); var t = canvasWidth + (viewportHasVScroll ? scrollbarDimensions.width : 0); $headerRowSpacer.width(t), options.createFooterRow && $footerRowSpacer.width(t), options.createPreHeaderPanel && $preHeaderPanelSpacer.width(t), canvasWidth == o && !e || applyColumnWidths() } function disableSelection(e) { e && e.jquery && e.attr("unselectable", "on").css("MozUserSelect", "none").on("selectstart.ui", function () { return !1 }) } function getMaxSupportedCssHeight() { for (var e = 1e6, o = navigator.userAgent.toLowerCase().match(/firefox/) ? 6e6 : 1e9, t = $("<div style='display:none' />").appendTo(document.body); ;) { var l = 2 * e; if (t.css("height", l), o < l || t.height() !== l) break; e = l } return t.remove(), e } function getUID() { return uid } function getHeaderColumnWidthDiff() { return headerColumnWidthDiff } function getScrollbarDimensions() { return scrollbarDimensions } function bindAncestorScrollEvents() { for (var e = $canvas[0]; (e = e.parentNode) != document.body && null != e;)if (e == $viewport[0] || e.scrollWidth != e.clientWidth || e.scrollHeight != e.clientHeight) { var o = $(e); $boundAncestors = $boundAncestors ? $boundAncestors.add(o) : o, o.on("scroll." + uid, handleActiveCellPositionChange) } } function unbindAncestorScrollEvents() { $boundAncestors && ($boundAncestors.off("scroll." + uid), $boundAncestors = null) } function updateColumnHeader(e, o, t) { if (initialized) { var l = getColumnIndex(e); if (null != l) { var n = columns[l], r = $headers.children().eq(l); r && (void 0 !== o && (columns[l].name = o), void 0 !== t && (columns[l].toolTip = t), trigger(self.onBeforeHeaderCellDestroy, { node: r[0], column: n, grid: self }), r.attr("title", t || "").children().eq(0).html(o), trigger(self.onHeaderCellRendered, { node: r[0], column: n, grid: self })) } } } function getHeaderRow() { return $headerRow[0] } function getFooterRow() { return $footerRow[0] } function getPreHeaderPanel() { return $preHeaderPanel[0] } function getHeaderRowColumn(e) { var o = getColumnIndex(e), t = $headerRow.children().eq(o); return t && t[0] } function getFooterRowColumn(e) { var o = getColumnIndex(e), t = $footerRow.children().eq(o); return t && t[0] } function createColumnHeaders() { function e() { $(this).addClass("ui-state-hover") } function o() { $(this).removeClass("ui-state-hover") } $headers.find(".slick-header-column").each(function () { var e = $(this).data("column"); e && trigger(self.onBeforeHeaderCellDestroy, { node: this, column: e, grid: self }) }), $headers.empty(), $headers.width(getHeadersWidth()), $headerRow.find(".slick-headerrow-column").each(function () { var e = $(this).data("column"); e && trigger(self.onBeforeHeaderRowCellDestroy, { node: this, column: e, grid: self }) }), $headerRow.empty(), options.createFooterRow && ($footerRow.find(".slick-footerrow-column").each(function () { var e = $(this).data("column"); e && trigger(self.onBeforeFooterRowCellDestroy, { node: this, column: e }) }), $footerRow.empty()); for (var t = 0; t < columns.length; t++) { var l = columns[t], n = $("<div class='ui-state-default slick-header-column' />").html("<span class='slick-column-name'>" + l.name + "</span>").width(l.width - headerColumnWidthDiff).attr("id", "" + uid + l.id).attr("title", l.toolTip || "").data("column", l).addClass(l.headerCssClass || "").appendTo($headers); if ((options.enableColumnReorder || l.sortable) && n.on("mouseenter", e).on("mouseleave", o), l.sortable && (n.addClass("slick-header-sortable"), n.append("<span class='" + sortIndicatorCssClass + "' />")), trigger(self.onHeaderCellRendered, { node: n[0], column: l, grid: self }), options.showHeaderRow) { var r = $("<div class='ui-state-default slick-headerrow-column l" + t + " r" + t + "'></div>").data("column", l).appendTo($headerRow); trigger(self.onHeaderRowCellRendered, { node: r[0], column: l, grid: self }) } if (options.createFooterRow && options.showFooterRow) { var i = $("<div class='ui-state-default slick-footerrow-column l" + t + " r" + t + "'></div>").data("column", l).appendTo($footerRow); trigger(self.onFooterRowCellRendered, { node: i[0], column: l }) } } setSortColumns(sortColumns), setupColumnResize(), options.enableColumnReorder && ("function" == typeof options.enableColumnReorder ? options.enableColumnReorder(self, $headers, headerColumnWidthDiff, setColumns, setupColumnResize, columns, getColumnIndex, uid, trigger) : setupColumnReorder()) } function setupColumnSort() { $headers.click(function (e) { if (!columnResizeDragging && (e.metaKey = e.metaKey || e.ctrlKey, !$(e.target).hasClass("slick-resizable-handle"))) { var o = $(e.target).closest(".slick-header-column"); if (o.length) { var t = o.data("column"); if (t.sortable) { if (!getEditorLock().commitCurrentEdit()) return; for (var l = null, n = 0; n < sortColumns.length; n++)if (sortColumns[n].columnId == t.id) { (l = sortColumns[n]).sortAsc = !l.sortAsc; break } var r = !!l; options.tristateMultiColumnSort ? (l = l || { columnId: t.id, sortAsc: t.defaultSortAsc }, r && l.sortAsc && (sortColumns.splice(n, 1), l = null), options.multiColumnSort || (sortColumns = []), !l || r && options.multiColumnSort || sortColumns.push(l)) : e.metaKey && options.multiColumnSort ? l && sortColumns.splice(n, 1) : ((e.shiftKey || e.metaKey) && options.multiColumnSort || (sortColumns = []), l ? 0 == sortColumns.length && sortColumns.push(l) : (l = { columnId: t.id, sortAsc: t.defaultSortAsc }, sortColumns.push(l))), setSortColumns(sortColumns), 0 < sortColumns.length && (options.multiColumnSort ? trigger(self.onSort, { multiColumnSort: !0, sortCols: $.map(sortColumns, function (e) { return { sortCol: columns[getColumnIndex(e.columnId)], sortAsc: e.sortAsc } }), grid: self }, e) : trigger(self.onSort, { multiColumnSort: !1, sortCol: t, sortAsc: sortColumns[0].sortAsc, grid: self }, e)) } } } }) } function setupColumnReorder() { $headers.filter(":ui-sortable").sortable("destroy"), $headers.sortable({ containment: "parent", distance: 3, axis: "x", cursor: "default", tolerance: "intersection", helper: "clone", placeholder: "slick-sortable-placeholder ui-state-default slick-header-column", start: function (e, o) { o.placeholder.width(o.helper.outerWidth() - headerColumnWidthDiff), $(o.helper).addClass("slick-header-column-active") }, beforeStop: function (e, o) { $(o.helper).removeClass("slick-header-column-active") }, stop: function (e) { if (getEditorLock().commitCurrentEdit()) { for (var o = $headers.sortable("toArray"), t = [], l = 0; l < o.length; l++)t.push(columns[getColumnIndex(o[l].replace(uid, ""))]); setColumns(t), trigger(self.onColumnsReordered, { grid: self }), e.stopPropagation(), setupColumnResize() } else $(this).sortable("cancel") } }) } function setupColumnResize() { var s, a, c, d, u, h, t, l; (d = $headers.children()).find(".slick-resizable-handle").remove(), d.each(function (e, o) { e >= columns.length || columns[e].resizable && (void 0 === t && (t = e), l = e) }), void 0 !== t && d.each(function (i, e) { i >= columns.length || i < t || options.forceFitColumns && l <= i || ($(e), $("<div class='slick-resizable-handle' />").appendTo(e).on("dragstart", function (e, o) { if (!getEditorLock().commitCurrentEdit()) return !1; c = e.pageX, $(this).parent().addClass("slick-header-column-active"); var t = null, l = null; if (d.each(function (e, o) { e >= columns.length || (columns[e].previousWidth = $(o).outerWidth()) }), options.forceFitColumns) for (l = t = 0, s = i + 1; s < columns.length; s++)(a = columns[s]).resizable && (null !== l && (a.maxWidth ? l += a.maxWidth - a.previousWidth : l = null), t += a.previousWidth - Math.max(a.minWidth || 0, absoluteColumnMinWidth)); var n = 0, r = 0; for (s = 0; s <= i; s++)(a = columns[s]).resizable && (null !== r && (a.maxWidth ? r += a.maxWidth - a.previousWidth : r = null), n += a.previousWidth - Math.max(a.minWidth || 0, absoluteColumnMinWidth)); null === t && (t = 1e5), null === n && (n = 1e5), null === l && (l = 1e5), null === r && (r = 1e5), h = c + Math.min(t, r), u = c - Math.min(n, l) }).on("drag", function (e, o) { columnResizeDragging = !0; var t, l, n = Math.min(h, Math.max(u, e.pageX)) - c; if (n < 0) { for (l = n, s = i; 0 <= s; s--)(a = columns[s]).resizable && (t = Math.max(a.minWidth || 0, absoluteColumnMinWidth), l && a.previousWidth + l < t ? (l += a.previousWidth - t, a.width = t) : (a.width = a.previousWidth + l, l = 0)); if (options.forceFitColumns) for (l = -n, s = i + 1; s < columns.length; s++)(a = columns[s]).resizable && (l && a.maxWidth && a.maxWidth - a.previousWidth < l ? (l -= a.maxWidth - a.previousWidth, a.width = a.maxWidth) : (a.width = a.previousWidth + l, l = 0)) } else { for (l = n, s = i; 0 <= s; s--)(a = columns[s]).resizable && (l && a.maxWidth && a.maxWidth - a.previousWidth < l ? (l -= a.maxWidth - a.previousWidth, a.width = a.maxWidth) : (a.width = a.previousWidth + l, l = 0)); if (options.forceFitColumns) for (l = -n, s = i + 1; s < columns.length; s++)(a = columns[s]).resizable && (t = Math.max(a.minWidth || 0, absoluteColumnMinWidth), l && a.previousWidth + l < t ? (l += a.previousWidth - t, a.width = t) : (a.width = a.previousWidth + l, l = 0)) } applyColumnHeaderWidths(), options.syncColumnCellResize && applyColumnWidths() }).on("dragend", function (e, o) { var t; for ($(this).parent().removeClass("slick-header-column-active"), s = 0; s < columns.length; s++)a = columns[s], t = $(d[s]).outerWidth(), a.previousWidth !== t && a.rerenderOnResize && invalidateAllRows(); updateCanvasWidth(!0), render(), trigger(self.onColumnsResized, { grid: self }), setTimeout(function () { columnResizeDragging = !1 }, 300) })) }) } function getVBoxDelta(t) { var l = 0; return $.each(["borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom"], function (e, o) { l += parseFloat(t.css(o)) || 0 }), l } function measureCellPaddingAndBorder() { var t, e = ["borderLeftWidth", "borderRightWidth", "paddingLeft", "paddingRight"], o = ["borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom"], l = $.fn.jquery.split("."); jQueryNewWidthBehaviour = 1 == l[0] && 8 <= l[1] || 2 <= l[0], t = $("<div class='ui-state-default slick-header-column' style='visibility:hidden'>-</div>").appendTo($headers), headerColumnWidthDiff = headerColumnHeightDiff = 0, "border-box" != t.css("box-sizing") && "border-box" != t.css("-moz-box-sizing") && "border-box" != t.css("-webkit-box-sizing") && ($.each(e, function (e, o) { headerColumnWidthDiff += parseFloat(t.css(o)) || 0 }), $.each(o, function (e, o) { headerColumnHeightDiff += parseFloat(t.css(o)) || 0 })), t.remove(); var n = $("<div class='slick-row' />").appendTo($canvas); t = $("<div class='slick-cell' id='' style='visibility:hidden'>-</div>").appendTo(n), cellWidthDiff = cellHeightDiff = 0, "border-box" != t.css("box-sizing") && "border-box" != t.css("-moz-box-sizing") && "border-box" != t.css("-webkit-box-sizing") && ($.each(e, function (e, o) { cellWidthDiff += parseFloat(t.css(o)) || 0 }), $.each(o, function (e, o) { cellHeightDiff += parseFloat(t.css(o)) || 0 })), n.remove(), absoluteColumnMinWidth = Math.max(headerColumnWidthDiff, cellWidthDiff) } function createCssRules() { $style = $("<style type='text/css' rel='stylesheet' />").appendTo($("head")); for (var e = options.rowHeight - cellHeightDiff, o = ["." + uid + " .slick-header-column { left: 1000px; }", "." + uid + " .slick-top-panel { height:" + options.topPanelHeight + "px; }", "." + uid + " .slick-preheader-panel { height:" + options.preHeaderPanelHeight + "px; }", "." + uid + " .slick-headerrow-columns { height:" + options.headerRowHeight + "px; }", "." + uid + " .slick-footerrow-columns { height:" + options.footerRowHeight + "px; }", "." + uid + " .slick-cell { height:" + e + "px; }", "." + uid + " .slick-row { height:" + options.rowHeight + "px; }"], t = 0; t < columns.length; t++)o.push("." + uid + " .l" + t + " { }"), o.push("." + uid + " .r" + t + " { }"); $style[0].styleSheet ? $style[0].styleSheet.cssText = o.join(" ") : $style[0].appendChild(document.createTextNode(o.join(" "))) } function getColumnCssRules(e) { var o; if (!stylesheet) { var t = document.styleSheets; for (o = 0; o < t.length; o++)if ((t[o].ownerNode || t[o].owningElement) == $style[0]) { stylesheet = t[o]; break } if (!stylesheet) throw new Error("Cannot find stylesheet."); columnCssRulesL = [], columnCssRulesR = []; var l, n, r = stylesheet.cssRules || stylesheet.rules; for (o = 0; o < r.length; o++) { var i = r[o].selectorText; (l = /\.l\d+/.exec(i)) ? (n = parseInt(l[0].substr(2, l[0].length - 2), 10), columnCssRulesL[n] = r[o]) : (l = /\.r\d+/.exec(i)) && (n = parseInt(l[0].substr(2, l[0].length - 2), 10), columnCssRulesR[n] = r[o]) } } return { left: columnCssRulesL[e], right: columnCssRulesR[e] } } function removeCssRules() { $style.remove(), stylesheet = null } function destroy() { getEditorLock().cancelCurrentEdit(), trigger(self.onBeforeDestroy, { grid: self }); for (var e = plugins.length; e--;)unregisterPlugin(plugins[e]); options.enableColumnReorder && $headers.filter(":ui-sortable").sortable("destroy"), unbindAncestorScrollEvents(), $container.off(".slickgrid"), removeCssRules(), $canvas.off("draginit dragstart dragend drag"), $container.empty().removeClass(uid) } function trigger(e, o, t) { return t = t || new Slick.EventData, (o = o || {}).grid = self, e.notify(o, t, self) } function getEditorLock() { return options.editorLock } function getEditController() { return editController } function getColumnIndex(e) { return columnsById[e] } function autosizeColumns() { var e, o, t, l = [], n = 0, r = 0, i = viewportHasVScroll ? viewportW - scrollbarDimensions.width : viewportW; for (e = 0; e < columns.length; e++)o = columns[e], l.push(o.width), r += o.width, o.resizable && (n += o.width - Math.max(o.minWidth, absoluteColumnMinWidth)); for (t = r; i < r && n;) { var s = (r - i) / n; for (e = 0; e < columns.length && i < r; e++) { o = columns[e]; var a = l[e]; if (!(!o.resizable || a <= o.minWidth || a <= absoluteColumnMinWidth)) { var c = Math.max(o.minWidth, absoluteColumnMinWidth), d = Math.floor(s * (a - c)) || 1; r -= d = Math.min(d, a - c), n -= d, l[e] -= d } } if (t <= r) break; t = r } for (t = r; r < i;) { var u = i / r; for (e = 0; e < columns.length && r < i; e++) { o = columns[e]; var h, g = l[e]; r += h = !o.resizable || o.maxWidth <= g ? 0 : Math.min(Math.floor(u * g) - g, o.maxWidth - g || 1e6) || 1, l[e] += r <= i ? h : 0 } if (r <= t) break; t = r } var p = !1; for (e = 0; e < columns.length; e++)columns[e].rerenderOnResize && columns[e].width != l[e] && (p = !0), columns[e].width = l[e]; applyColumnHeaderWidths(), updateCanvasWidth(!0), p && (invalidateAllRows(), render()) } function applyColumnHeaderWidths() { if (initialized) { for (var e, o = 0, t = $headers.children(), l = columns.length; o < l; o++)e = $(t[o]), jQueryNewWidthBehaviour ? e.outerWidth() !== columns[o].width && e.outerWidth(columns[o].width) : e.width() !== columns[o].width - headerColumnWidthDiff && e.width(columns[o].width - headerColumnWidthDiff); updateColumnCaches() } } function applyColumnWidths() { for (var e, o, t = 0, l = 0; l < columns.length; l++)e = columns[l].width, (o = getColumnCssRules(l)).left.style.left = t + "px", o.right.style.right = canvasWidth - t - e + "px", t += columns[l].width } function setSortColumn(e, o) { setSortColumns([{ columnId: e, sortAsc: o }]) } function setSortColumns(e) { sortColumns = e; var l = options.numberedMultiColumnSort && 1 < sortColumns.length, n = $headers.children(), r = n.removeClass("slick-header-column-sorted").find("." + sortIndicatorCssClass).removeClass("slick-sort-indicator-asc slick-sort-indicator-desc"); l && r.text(""), $.each(sortColumns, function (e, o) { null == o.sortAsc && (o.sortAsc = !0); var t = getColumnIndex(o.columnId); null != t && (r = n.eq(t).addClass("slick-header-column-sorted").find("." + sortIndicatorCssClass).addClass(o.sortAsc ? "slick-sort-indicator-asc" : "slick-sort-indicator-desc"), l && r.text(e + 1)) }) } function getSortColumns() { return sortColumns } function handleSelectedRangesChanged(e, o) { selectedRows = []; for (var t = {}, l = 0; l < o.length; l++)for (var n = o[l].fromRow; n <= o[l].toRow; n++) { t[n] || (selectedRows.push(n), t[n] = {}); for (var r = o[l].fromCell; r <= o[l].toCell; r++)canCellBeSelected(n, r) && (t[n][columns[r].id] = options.selectedCellCssClass) } setCellCssStyles(options.selectedCellCssClass, t), trigger(self.onSelectedRowsChanged, { rows: getSelectedRows(), grid: self }, e) } function getColumns() { return columns } function updateColumnCaches() { columnPosLeft = [], columnPosRight = []; for (var e = 0, o = 0, t = columns.length; o < t; o++)columnPosLeft[o] = e, columnPosRight[o] = e + columns[o].width, e += columns[o].width } function setColumns(e) { columns = e, columnsById = {}; for (var o = 0; o < columns.length; o++) { var t = columns[o] = $.extend({}, columnDefaults, columns[o]); columnsById[t.id] = o, t.minWidth && t.width < t.minWidth && (t.width = t.minWidth), t.maxWidth && t.width > t.maxWidth && (t.width = t.maxWidth) } updateColumnCaches(), initialized && (invalidateAllRows(), createColumnHeaders(), removeCssRules(), createCssRules(), resizeCanvas(), applyColumnWidths(), handleScroll()) } function getOptions() { return options } function setOptions(e, o) { getEditorLock().commitCurrentEdit() && (makeActiveCellNormal(), options.enableAddRow !== e.enableAddRow && invalidateRow(getDataLength()), options = $.extend(options, e), validateAndEnforceOptions(), $viewport.css("overflow-y", options.autoHeight ? "hidden" : "auto"), o || render()) } function validateAndEnforceOptions() { options.autoHeight && (options.leaveSpaceForNewRows = !1) } function setData(e, o) { data = e, invalidateAllRows(), updateRowCount(), o && scrollTo(0) } function getData() { return data } function getDataLength() { return data.getLength ? data.getLength() : data.length } function getDataLengthIncludingAddNew() { return getDataLength() + (options.enableAddRow && (!pagingActive || pagingIsLastPage) ? 1 : 0) } function getDataItem(e) { return data.getItem ? data.getItem(e) : data[e] } function getTopPanel() { return $topPanel[0] } function setTopPanelVisibility(e) { options.showTopPanel != e && ((options.showTopPanel = e) ? $topPanelScroller.slideDown("fast", resizeCanvas) : $topPanelScroller.slideUp("fast", resizeCanvas)) } function setHeaderRowVisibility(e) { options.showHeaderRow != e && ((options.showHeaderRow = e) ? $headerRowScroller.slideDown("fast", resizeCanvas) : $headerRowScroller.slideUp("fast", resizeCanvas)) } function setFooterRowVisibility(e) { options.showFooterRow != e && ((options.showFooterRow = e) ? $footerRowScroller.slideDown("fast", resizeCanvas) : $footerRowScroller.slideUp("fast", resizeCanvas)) } function setPreHeaderPanelVisibility(e) { options.showPreHeaderPanel != e && ((options.showPreHeaderPanel = e) ? $preHeaderPanelScroller.slideDown("fast", resizeCanvas) : $preHeaderPanelScroller.slideUp("fast", resizeCanvas)) } function getContainerNode() { return $container.get(0) } function getRowTop(e) { return options.rowHeight * e - offset } function getRowFromPosition(e) { return Math.floor((e + offset) / options.rowHeight) } function scrollTo(e) { e = Math.max(e, 0), e = Math.min(e, th - viewportH + (viewportHasHScroll ? scrollbarDimensions.height : 0)); var o = offset; page = Math.min(n - 1, Math.floor(e / ph)); var t = e - (offset = Math.round(page * cj)); offset != o && (cleanupRows(getVisibleRange(t)), updateRowPositions()); prevScrollTop != t && (vScrollDir = prevScrollTop + o < t + offset ? 1 : -1, $viewport[0].scrollTop = lastRenderedScrollTop = scrollTop = prevScrollTop = t, trigger(self.onViewportChanged, { grid: self })) } function defaultFormatter(e, o, t, l, n) { return null == t ? "" : (t + "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;") } function getFormatter(e, o) { var t = data.getItemMetadata && data.getItemMetadata(e), l = t && t.columns && (t.columns[o.id] || t.columns[getColumnIndex(o.id)]); return l && l.formatter || t && t.formatter || o.formatter || options.formatterFactory && options.formatterFactory.getFormatter(o) || options.defaultFormatter } function getEditor(e, o) { var t = columns[o], l = data.getItemMetadata && data.getItemMetadata(e), n = l && l.columns; return n && n[t.id] && void 0 !== n[t.id].editor ? n[t.id].editor : n && n[o] && void 0 !== n[o].editor ? n[o].editor : t.editor || options.editorFactory && options.editorFactory.getEditor(t) } function getDataItemValueForColumn(e, o) { return options.dataItemColumnValueExtractor ? options.dataItemColumnValueExtractor(e, o) : e[o.field] } function appendRowHtml(e, o, t, l) { var n = getDataItem(o), r = "slick-row" + (o < l && !n ? " loading" : "") + (o === activeRow ? " active" : "") + (o % 2 == 1 ? " odd" : " even"); n || (r += " " + options.addNewRowCssClass); var i, s, a = data.getItemMetadata && data.getItemMetadata(o); a && a.cssClasses && (r += " " + a.cssClasses), e.push("<div class='ui-widget-content " + r + "' style='top:" + getRowTop(o) + "px'>"); for (var c = 0, d = columns.length; c < d; c++) { if (s = columns[c], i = 1, a && a.columns) { var u = a.columns[s.id] || a.columns[c]; "*" === (i = u && u.colspan || 1) && (i = d - c) } if (columnPosRight[Math.min(d - 1, c + i - 1)] > t.leftPx) { if (columnPosLeft[c] > t.rightPx) break; appendCellHtml(e, o, c, i, n) } 1 < i && (c += i - 1) } e.push("</div>") } function appendCellHtml(e, o, t, l, n) { var r = columns[t], i = "slick-cell l" + t + " r" + Math.min(columns.length - 1, t + l - 1) + (r.cssClass ? " " + r.cssClass : ""); for (var s in o === activeRow && t === activeCell && (i += " active"), cellCssClasses) cellCssClasses[s][o] && cellCssClasses[s][o][r.id] && (i += " " + cellCssClasses[s][o][r.id]); var a = null, c = ""; n && (a = getDataItemValueForColumn(n, r), null == (c = getFormatter(o, r)(o, t, a, r, n)) && (c = "")); var d = trigger(self.onBeforeAppendCell, { row: o, cell: t, grid: self, value: a, dataContext: n }) || ""; d += c.addClasses ? (d ? " " : "") + c.addClasses : "", e.push("<div class='" + i + (d ? " " + d : "") + "'>"), n && e.push("[object Object]" !== Object.prototype.toString.call(c) ? c : c.text), e.push("</div>"), rowsCache[o].cellRenderQueue.push(t), rowsCache[o].cellColSpans[t] = l } function cleanupRows(e) { for (var o in rowsCache) (o = parseInt(o, 10)) !== activeRow && (o < e.top || o > e.bottom) && removeRowFromCache(o); options.enableAsyncPostRenderCleanup && startPostProcessingCleanup() } function invalidate() { updateRowCount(), invalidateAllRows(), render() } function invalidateAllRows() { for (var e in currentEditor && makeActiveCellNormal(), rowsCache) removeRowFromCache(e); options.enableAsyncPostRenderCleanup && startPostProcessingCleanup() } function queuePostProcessedRowForCleanup(e, o, t) { for (var l in postProcessgroupId++ , o) o.hasOwnProperty(l) && postProcessedCleanupQueue.push({ actionType: "C", groupId: postProcessgroupId, node: e.cellNodesByColumnIdx[0 | l], columnIdx: 0 | l, rowIdx: t }); postProcessedCleanupQueue.push({ actionType: "R", groupId: postProcessgroupId, node: e.rowNode }), $(e.rowNode).detach() } function queuePostProcessedCellForCleanup(e, o, t) { postProcessedCleanupQueue.push({ actionType: "C", groupId: postProcessgroupId, node: e, columnIdx: o, rowIdx: t }), $(e).detach() } function removeRowFromCache(e) { var o = rowsCache[e]; o && (rowNodeFromLastMouseWheelEvent === o.rowNode ? (o.rowNode.style.display = "none", zombieRowNodeFromLastMouseWheelEvent = rowNodeFromLastMouseWheelEvent, zombieRowCacheFromLastMouseWheelEvent = o, zombieRowPostProcessedFromLastMouseWheelEvent = postProcessedRows[e]) : options.enableAsyncPostRenderCleanup && postProcessedRows[e] ? queuePostProcessedRowForCleanup(o, postProcessedRows[e], e) : $canvas[0].removeChild(o.rowNode), delete rowsCache[e], delete postProcessedRows[e], renderedRows-- , counter_rows_removed++) } function invalidateRows(e) { var o, t; if (e && e.length) { for (vScrollDir = 0, t = e.length, o = 0; o < t; o++)currentEditor && activeRow === e[o] && makeActiveCellNormal(), rowsCache[e[o]] && removeRowFromCache(e[o]); options.enableAsyncPostRenderCleanup && startPostProcessingCleanup() } } function invalidateRow(e) { invalidateRows([e]) } function applyFormatResultToCellNode(e, o, t) { "[object Object]" === Object.prototype.toString.call(e) ? (o.innerHTML = e.text, e.removeClasses && !t && $(o).removeClass(e.removeClasses), e.addClasses && $(o).addClass(e.addClasses)) : o.innerHTML = e } function updateCell(e, o) { var t = getCellNode(e, o); if (t) { var l = columns[o], n = getDataItem(e); if (currentEditor && activeRow === e && activeCell === o) currentEditor.loadValue(n); else applyFormatResultToCellNode(n ? getFormatter(e, l)(e, o, getDataItemValueForColumn(n, l), l, n) : "", t), invalidatePostProcessingResults(e) } } function updateRow(e) { var o = rowsCache[e]; if (o) { ensureCellNodesInRowsCache(e); var t = getDataItem(e); for (var l in o.cellNodesByColumnIdx) if (o.cellNodesByColumnIdx.hasOwnProperty(l)) { var n = columns[l |= 0], r = o.cellNodesByColumnIdx[l]; e === activeRow && l === activeCell && currentEditor ? currentEditor.loadValue(t) : t ? applyFormatResultToCellNode(getFormatter(e, n)(e, l, getDataItemValueForColumn(t, n), n, t), r) : r.innerHTML = "" } invalidatePostProcessingResults(e) } } function getViewportHeight() { return parseFloat($.css($container[0], "height", !0)) - parseFloat($.css($container[0], "paddingTop", !0)) - parseFloat($.css($container[0], "paddingBottom", !0)) - parseFloat($.css($headerScroller[0], "height")) - getVBoxDelta($headerScroller) - (options.showTopPanel ? options.topPanelHeight + getVBoxDelta($topPanelScroller) : 0) - (options.showHeaderRow ? options.headerRowHeight + getVBoxDelta($headerRowScroller) : 0) - (options.createFooterRow && options.showFooterRow ? options.footerRowHeight + getVBoxDelta($footerRowScroller) : 0) - (options.createPreHeaderPanel && options.showPreHeaderPanel ? options.preHeaderPanelHeight + getVBoxDelta($preHeaderPanelScroller) : 0) } function resizeCanvas() { initialized && (viewportH = options.autoHeight ? options.rowHeight * getDataLengthIncludingAddNew() : getViewportHeight(), numVisibleRows = Math.ceil(viewportH / options.rowHeight), viewportW = parseFloat($.css($container[0], "width", !0)), options.autoHeight || $viewport.height(viewportH), options.forceFitColumns && autosizeColumns(), updateRowCount(), handleScroll(), lastRenderedScrollLeft = -1, render()) } function updatePagingStatusFromView(e) { pagingActive = 0 !== e.pageSize, pagingIsLastPage = e.pageNum == e.totalPages - 1 } function updateRowCount() { if (initialized) { var e = getDataLength(), o = getDataLengthIncludingAddNew() + (options.leaveSpaceForNewRows ? numVisibleRows - 1 : 0), t = viewportHasVScroll; viewportHasVScroll = !options.autoHeight && o * options.rowHeight > viewportH, viewportHasHScroll = canvasWidth > viewportW - scrollbarDimensions.width, makeActiveCellNormal(); var l = e - 1; for (var r in rowsCache) l < r && removeRowFromCache(r); options.enableAsyncPostRenderCleanup && startPostProcessingCleanup(), activeCellNode && l < activeRow && resetActiveCell(); var i = h; th = Math.max(options.rowHeight * o, viewportH - scrollbarDimensions.height), cj = th < maxSupportedCssHeight ? (h = ph = th, n = 1, 0) : (ph = (h = maxSupportedCssHeight) / 100, n = Math.floor(th / ph), (th - h) / (n - 1)), h !== i && ($canvas.css("height", h), scrollTop = $viewport[0].scrollTop); var s = scrollTop + offset <= th - viewportH; 0 == th || 0 == scrollTop ? page = offset = 0 : scrollTo(s ? scrollTop + offset : th - viewportH), h != i && options.autoHeight && resizeCanvas(), options.forceFitColumns && t != viewportHasVScroll && autosizeColumns(), updateCanvasWidth(!1) } } function getVisibleRange(e, o) { return null == e && (e = scrollTop), null == o && (o = scrollLeft), { top: getRowFromPosition(e), bottom: getRowFromPosition(e + viewportH) + 1, leftPx: o, rightPx: o + viewportW } } function getRenderedRange(e, o) { var t = getVisibleRange(e, o), l = Math.round(viewportH / options.rowHeight); return -1 == vScrollDir ? (t.top -= l, t.bottom += 3) : 1 == vScrollDir ? (t.top -= 3, t.bottom += l) : (t.top -= 3, t.bottom += 3), t.top = Math.max(0, t.top), t.bottom = Math.min(getDataLengthIncludingAddNew() - 1, t.bottom), t.leftPx -= viewportW, t.rightPx += viewportW, t.leftPx = Math.max(0, t.leftPx), t.rightPx = Math.min(canvasWidth, t.rightPx), t } function ensureCellNodesInRowsCache(e) { var o = rowsCache[e]; if (o && o.cellRenderQueue.length) for (var t = o.rowNode.lastChild; o.cellRenderQueue.length;) { var l = o.cellRenderQueue.pop(); t = (o.cellNodesByColumnIdx[l] = t).previousSibling } } function cleanUpCells(e, o) { var t, l, n = rowsCache[o], r = []; for (var i in n.cellNodesByColumnIdx) if (n.cellNodesByColumnIdx.hasOwnProperty(i)) { i |= 0; var s = n.cellColSpans[i]; (columnPosLeft[i] > e.rightPx || columnPosRight[Math.min(columns.length - 1, i + s - 1)] < e.leftPx) && (o == activeRow && i == activeCell || r.push(i)) } for (postProcessgroupId++; null != (t = r.pop());)l = n.cellNodesByColumnIdx[t], options.enableAsyncPostRenderCleanup && postProcessedRows[o] && postProcessedRows[o][t] ? queuePostProcessedCellForCleanup(l, t, o) : n.rowNode.removeChild(l), delete n.cellColSpans[t], delete n.cellNodesByColumnIdx[t], postProcessedRows[o] && delete postProcessedRows[o][t], 0 } function cleanUpAndRenderCells(e) { for (var o, t, l, n = [], r = [], i = e.top, s = e.bottom; i <= s; i++)if (o = rowsCache[i]) { ensureCellNodesInRowsCache(i), cleanUpCells(e, i), t = 0; var a = data.getItemMetadata && data.getItemMetadata(i); a = a && a.columns; for (var c = getDataItem(i), d = 0, u = columns.length; d < u && !(columnPosLeft[d] > e.rightPx); d++)if (null == (l = o.cellColSpans[d])) { if (l = 1, a) { var h = a[columns[d].id] || a[d]; "*" === (l = h && h.colspan || 1) && (l = u - d) } columnPosRight[Math.min(u - 1, d + l - 1)] > e.leftPx && (appendCellHtml(n, i, d, l, c), t++), d += 1 < l ? l - 1 : 0 } else d += 1 < l ? l - 1 : 0; t && (t, r.push(i)) } if (n.length) { var g, p, f = document.createElement("div"); for (f.innerHTML = n.join(""); null != (g = r.pop());) { var m; for (o = rowsCache[g]; null != (m = o.cellRenderQueue.pop());)p = f.lastChild, o.rowNode.appendChild(p), o.cellNodesByColumnIdx[m] = p } } } function renderRows(e) { for (var o = $canvas[0], t = [], l = [], n = !1, r = getDataLength(), i = e.top, s = e.bottom; i <= s; i++)rowsCache[i] || (renderedRows++ , l.push(i), rowsCache[i] = { rowNode: null, cellColSpans: [], cellNodesByColumnIdx: [], cellRenderQueue: [] }, appendRowHtml(t, i, e, r), activeCellNode && activeRow === i && (n = !0), counter_rows_rendered++); if (l.length) { var a = document.createElement("div"); a.innerHTML = t.join(""); for (i = 0, s = l.length; i < s; i++)rowsCache[l[i]].rowNode = o.appendChild(a.firstChild); n && (activeCellNode = getCellNode(activeRow, activeCell)) } } function startPostProcessing() { options.enableAsyncPostRender && (clearTimeout(h_postrender), h_postrender = setTimeout(asyncPostProcessRows, options.asyncPostRenderDelay)) } function startPostProcessingCleanup() { options.enableAsyncPostRenderCleanup && (clearTimeout(h_postrenderCleanup), h_postrenderCleanup = setTimeout(asyncPostProcessCleanupRows, options.asyncPostRenderCleanupDelay)) } function invalidatePostProcessingResults(e) { for (var o in postProcessedRows[e]) postProcessedRows[e].hasOwnProperty(o) && (postProcessedRows[e][o] = "C"); postProcessFromRow = Math.min(postProcessFromRow, e), postProcessToRow = Math.max(postProcessToRow, e), startPostProcessing() } function updateRowPositions() { for (var e in rowsCache) rowsCache[e].rowNode.style.top = getRowTop(e) + "px" } function render() { if (initialized) { var e = getVisibleRange(), o = getRenderedRange(); cleanupRows(o), lastRenderedScrollLeft != scrollLeft && cleanUpAndRenderCells(o), renderRows(o), postProcessFromRow = e.top, postProcessToRow = Math.min(getDataLengthIncludingAddNew() - 1, e.bottom), startPostProcessing(), lastRenderedScrollTop = scrollTop, lastRenderedScrollLeft = scrollLeft, h_render = null } } function handleHeaderScroll() { handleElementScroll($headerScroller[0]) } function handleHeaderRowScroll() { handleElementScroll($headerRowScroller[0]) } function handleFooterRowScroll() { handleElementScroll($footerRowScroller[0]) } function handlePreHeaderPanelScroll() { handleElementScroll($preHeaderPanelScroller[0]) } function handleElementScroll(e) { var o = e.scrollLeft; o != $viewport[0].scrollLeft && ($viewport[0].scrollLeft = o) } function handleScroll() { scrollTop = $viewport[0].scrollTop, scrollLeft = $viewport[0].scrollLeft; var e = Math.abs(scrollTop - prevScrollTop), o = Math.abs(scrollLeft - prevScrollLeft); if (o && (prevScrollLeft = scrollLeft, $headerScroller[0].scrollLeft = scrollLeft, $topPanelScroller[0].scrollLeft = scrollLeft, $headerRowScroller[0].scrollLeft = scrollLeft, options.createFooterRow && ($footerRowScroller[0].scrollLeft = scrollLeft), options.createPreHeaderPanel && ($preHeaderPanelScroller[0].scrollLeft = scrollLeft)), e) if (vScrollDir = prevScrollTop < scrollTop ? 1 : -1, prevScrollTop = scrollTop, e < viewportH) scrollTo(scrollTop + offset); else { var t = offset; page = h == viewportH ? 0 : Math.min(n - 1, Math.floor(scrollTop * ((th - viewportH) / (h - viewportH)) * (1 / ph))), t != (offset = Math.round(page * cj)) && invalidateAllRows() } (o || e) && (h_render && clearTimeout(h_render), (20 < Math.abs(lastRenderedScrollTop - scrollTop) || 20 < Math.abs(lastRenderedScrollLeft - scrollLeft)) && (options.forceSyncScrolling || Math.abs(lastRenderedScrollTop - scrollTop) < viewportH && Math.abs(lastRenderedScrollLeft - scrollLeft) < viewportW ? render() : h_render = setTimeout(render, 50), trigger(self.onViewportChanged, { grid: self }))), trigger(self.onScroll, { scrollLeft: scrollLeft, scrollTop: scrollTop, grid: self }) } function asyncPostProcessRows() { for (var e = getDataLength(); postProcessFromRow <= postProcessToRow;) { var o = 0 <= vScrollDir ? postProcessFromRow++ : postProcessToRow--, t = rowsCache[o]; if (t && !(e <= o)) { for (var l in postProcessedRows[o] || (postProcessedRows[o] = {}), ensureCellNodesInRowsCache(o), t.cellNodesByColumnIdx) if (t.cellNodesByColumnIdx.hasOwnProperty(l)) { var n = columns[l |= 0], r = postProcessedRows[o][l]; if (n.asyncPostRender && "R" !== r) { var i = t.cellNodesByColumnIdx[l]; i && n.asyncPostRender(i, o, getDataItem(o), n, "C" === r), postProcessedRows[o][l] = "R" } } return void (h_postrender = setTimeout(asyncPostProcessRows, options.asyncPostRenderDelay)) } } } function asyncPostProcessCleanupRows() { if (0 < postProcessedCleanupQueue.length) { for (var e = postProcessedCleanupQueue[0].groupId; 0 < postProcessedCleanupQueue.length && postProcessedCleanupQueue[0].groupId == e;) { var o = postProcessedCleanupQueue.shift(); if ("R" == o.actionType && $(o.node).remove(), "C" == o.actionType) { var t = columns[o.columnIdx]; t.asyncPostRenderCleanup && o.node && t.asyncPostRenderCleanup(o.node, o.rowIdx, t) } } h_postrenderCleanup = setTimeout(asyncPostProcessCleanupRows, options.asyncPostRenderCleanupDelay) } } function updateCellCssStylesOnRenderedRows(e, o) { var t, l, n, r; for (var i in rowsCache) { if (r = o && o[i], n = e && e[i], r) for (l in r) n && r[l] == n[l] || (t = getCellNode(i, getColumnIndex(l))) && $(t).removeClass(r[l]); if (n) for (l in n) r && r[l] == n[l] || (t = getCellNode(i, getColumnIndex(l))) && $(t).addClass(n[l]) } } function addCellCssStyles(e, o) { if (cellCssClasses[e]) throw new Error("addCellCssStyles: cell CSS hash with key '" + e + "' already exists."); updateCellCssStylesOnRenderedRows(cellCssClasses[e] = o, null), trigger(self.onCellCssStylesChanged, { key: e, hash: o, grid: self }) } function removeCellCssStyles(e) { cellCssClasses[e] && (updateCellCssStylesOnRenderedRows(null, cellCssClasses[e]), delete cellCssClasses[e], trigger(self.onCellCssStylesChanged, { key: e, hash: null, grid: self })) } function setCellCssStyles(e, o) { var t = cellCssClasses[e]; updateCellCssStylesOnRenderedRows(cellCssClasses[e] = o, t), trigger(self.onCellCssStylesChanged, { key: e, hash: o, grid: self }) } function getCellCssStyles(e) { return cellCssClasses[e] } function flashCell(e, o, t) { if (t = t || 100, rowsCache[e]) { var l = $(getCellNode(e, o)); !function e(o) { o && setTimeout(function () { l.queue(function () { l.toggleClass(options.cellFlashingCssClass).dequeue(), e(o - 1) }) }, t) }(4) } } function handleMouseWheel(e) { var o = $(e.target).closest(".slick-row")[0]; o != rowNodeFromLastMouseWheelEvent && (zombieRowNodeFromLastMouseWheelEvent && zombieRowNodeFromLastMouseWheelEvent != o && (options.enableAsyncPostRenderCleanup && zombieRowPostProcessedFromLastMouseWheelEvent ? queuePostProcessedRowForCleanup(zombieRowCacheFromLastMouseWheelEvent, zombieRowPostProcessedFromLastMouseWheelEvent) : $canvas[0].removeChild(zombieRowNodeFromLastMouseWheelEvent), zombieRowPostProcessedFromLastMouseWheelEvent = zombieRowCacheFromLastMouseWheelEvent = zombieRowNodeFromLastMouseWheelEvent = null, options.enableAsyncPostRenderCleanup && startPostProcessingCleanup()), rowNodeFromLastMouseWheelEvent = o) } function handleDragInit(e, o) { var t = getCellFromEvent(e); if (!t || !cellExists(t.row, t.cell)) return !1; var l = trigger(self.onDragInit, o, e); return !!e.isImmediatePropagationStopped() && l } function handleDragStart(e, o) { var t = getCellFromEvent(e); if (!t || !cellExists(t.row, t.cell)) return !1; var l = trigger(self.onDragStart, o, e); return !!e.isImmediatePropagationStopped() && l } function handleDrag(e, o) { return trigger(self.onDrag, o, e) } function handleDragEnd(e, o) { trigger(self.onDragEnd, o, e) } function handleKeyDown(e) { trigger(self.onKeyDown, { row: activeRow, cell: activeCell, grid: self }, e); var o = e.isImmediatePropagationStopped(), t = Slick.keyCode; if (!o && !e.shiftKey && !e.altKey) { if (options.editable && currentEditor && currentEditor.keyCaptureList && -1 < currentEditor.keyCaptureList.indexOf(e.which)) return; e.which == t.HOME ? o = e.ctrlKey ? navigateTop() : navigateRowStart() : e.which == t.END && (o = e.ctrlKey ? navigateBottom() : navigateRowEnd()) } if (!o) if (e.shiftKey || e.altKey || e.ctrlKey) e.which != t.TAB || !e.shiftKey || e.ctrlKey || e.altKey || (o = navigatePrev()); else { if (options.editable && currentEditor && currentEditor.keyCaptureList && -1 < currentEditor.keyCaptureList.indexOf(e.which)) return; if (e.which == t.ESCAPE) { if (!getEditorLock().isActive()) return; cancelEditAndSetFocus() } else e.which == t.PAGE_DOWN ? (navigatePageDown(), o = !0) : e.which == t.PAGE_UP ? (navigatePageUp(), o = !0) : e.which == t.LEFT ? o = navigateLeft() : e.which == t.RIGHT ? o = navigateRight() : e.which == t.UP ? o = navigateUp() : e.which == t.DOWN ? o = navigateDown() : e.which == t.TAB ? o = navigateNext() : e.which == t.ENTER && (options.editable && (currentEditor ? activeRow === getDataLength() ? navigateDown() : commitEditAndSetFocus() : getEditorLock().commitCurrentEdit() && makeActiveCellEditable()), o = !0) } if (o) { e.stopPropagation(), e.preventDefault(); try { e.originalEvent.keyCode = 0 } catch (e) { } } } function handleClick(e) { currentEditor || e.target == document.activeElement && !$(e.target).hasClass("slick-cell") || setFocus(); var o = getCellFromEvent(e); if (o && (null === currentEditor || activeRow != o.row || activeCell != o.cell) && (trigger(self.onClick, { row: o.row, cell: o.cell, grid: self }, e), !e.isImmediatePropagationStopped() && canCellBeActive(o.row, o.cell) && (!getEditorLock().isActive() || getEditorLock().commitCurrentEdit()))) { scrollRowIntoView(o.row, !1); var t = e.target && e.target.className === Slick.preClickClassName; setActiveCellInternal(getCellNode(o.row, o.cell), null, t) } } function handleContextMenu(e) { var o = $(e.target).closest(".slick-cell", $canvas); 0 !== o.length && (activeCellNode === o[0] && null !== currentEditor || trigger(self.onContextMenu, { grid: self }, e)) } function handleDblClick(e) { var o = getCellFromEvent(e); !o || null !== currentEditor && activeRow == o.row && activeCell == o.cell || (trigger(self.onDblClick, { row: o.row, cell: o.cell, grid: self }, e), e.isImmediatePropagationStopped() || options.editable && gotoCell(o.row, o.cell, !0)) } function handleHeaderMouseEnter(e) { trigger(self.onHeaderMouseEnter, { column: $(this).data("column"), grid: self }, e) } function handleHeaderMouseLeave(e) { trigger(self.onHeaderMouseLeave, { column: $(this).data("column"), grid: self }, e) } function handleHeaderContextMenu(e) { var o = $(e.target).closest(".slick-header-column", ".slick-header-columns"), t = o && o.data("column"); trigger(self.onHeaderContextMenu, { column: t, grid: self }, e) } function handleHeaderClick(e) { if (!columnResizeDragging) { var o = $(e.target).closest(".slick-header-column", ".slick-header-columns"), t = o && o.data("column"); t && trigger(self.onHeaderClick, { column: t, grid: self }, e) } } function handleMouseEnter(e) { trigger(self.onMouseEnter, { grid: self }, e) } function handleMouseLeave(e) { trigger(self.onMouseLeave, { grid: self }, e) } function cellExists(e, o) { return !(e < 0 || e >= getDataLength() || o < 0 || o >= columns.length) } function getCellFromPoint(e, o) { for (var t = getRowFromPosition(o), l = 0, n = 0, r = 0; r < columns.length && n < e; r++)n += columns[r].width, l++; return l < 0 && (l = 0), { row: t, cell: l - 1 } } function getCellFromNode(e) { var o = /l\d+/.exec(e.className); if (!o) throw new Error("getCellFromNode: cannot get cell - " + e.className); return parseInt(o[0].substr(1, o[0].length - 1), 10) } function getRowFromNode(e) { for (var o in rowsCache) if (rowsCache[o].rowNode === e) return 0 | o; return null } function getCellFromEvent(e) { var o = $(e.target).closest(".slick-cell", $canvas); if (!o.length) return null; var t = getRowFromNode(o[0].parentNode), l = getCellFromNode(o[0]); return null == t || null == l ? null : { row: t, cell: l } } function getCellNodeBox(e, o) { if (!cellExists(e, o)) return null; for (var t = getRowTop(e), l = t + options.rowHeight - 1, n = 0, r = 0; r < o; r++)n += columns[r].width; return { top: t, left: n, bottom: l, right: n + columns[o].width } } function resetActiveCell() { setActiveCellInternal(null, !1) } function setFocus() { -1 == tabbingDirection ? $focusSink[0].focus() : $focusSink2[0].focus() } function scrollCellIntoView(e, o, t) { scrollRowIntoView(e, t); var l = getColspan(e, o); internalScrollColumnIntoView(columnPosLeft[o], columnPosRight[o + (1 < l ? l - 1 : 0)]) } function internalScrollColumnIntoView(e, o) { var t = scrollLeft + viewportW; e < scrollLeft ? ($viewport.scrollLeft(e), handleScroll(), render()) : t < o && ($viewport.scrollLeft(Math.min(e, o - $viewport[0].clientWidth)), handleScroll(), render()) } function scrollColumnIntoView(e) { internalScrollColumnIntoView(columnPosLeft[e], columnPosRight[e]) } function setActiveCellInternal(e, o, t, l) { null !== activeCellNode && (makeActiveCellNormal(), $(activeCellNode).removeClass("active"), rowsCache[activeRow] && $(rowsCache[activeRow].rowNode).removeClass("active")); null != (activeCellNode = e) ? (activeRow = getRowFromNode(activeCellNode.parentNode), activeCell = activePosX = getCellFromNode(activeCellNode), null == o && (o = activeRow == getDataLength() || options.autoEdit), options.showCellSelection && ($(activeCellNode).addClass("active"), $(rowsCache[activeRow].rowNode).addClass("active")), options.editable && o && isCellPotentiallyEditable(activeRow, activeCell) && (clearTimeout(h_editorLoader), options.asyncEditorLoading ? h_editorLoader = setTimeout(function () { makeActiveCellEditable(void 0, t) }, options.asyncEditorLoadDelay) : makeActiveCellEditable(void 0, t))) : activeRow = activeCell = null, l || trigger(self.onActiveCellChanged, getActiveCell()) } function clearTextSelection() { if (document.selection && document.selection.empty) try { document.selection.empty() } catch (e) { } else if (window.getSelection) { var e = window.getSelection(); e && e.removeAllRanges && e.removeAllRanges() } } function isCellPotentiallyEditable(e, o) { var t = getDataLength(); return !(e < t && !getDataItem(e)) && (!(columns[o].cannotTriggerInsert && t <= e) && !!getEditor(e, o)) } function makeActiveCellNormal() { if (currentEditor) { if (trigger(self.onBeforeCellEditorDestroy, { editor: currentEditor, grid: self }), currentEditor.destroy(), currentEditor = null, activeCellNode) { var e = getDataItem(activeRow); if ($(activeCellNode).removeClass("editable invalid"), e) { var o = columns[activeCell]; applyFormatResultToCellNode(getFormatter(activeRow, o)(activeRow, activeCell, getDataItemValueForColumn(e, o), o, e, self), activeCellNode), invalidatePostProcessingResults(activeRow) } } navigator.userAgent.toLowerCase().match(/msie/) && clearTextSelection(), getEditorLock().deactivate(editController) } } function makeActiveCellEditable(e, o) { if (activeCellNode) { if (!options.editable) throw new Error("Grid : makeActiveCellEditable : should never get called when options.editable is false"); if (clearTimeout(h_editorLoader), isCellPotentiallyEditable(activeRow, activeCell)) { var t = columns[activeCell], l = getDataItem(activeRow); if (!1 !== trigger(self.onBeforeEditCell, { row: activeRow, cell: activeCell, item: l, column: t, grid: self })) { getEditorLock().activate(editController), $(activeCellNode).addClass("editable"); var n = e || getEditor(activeRow, activeCell); e || n.suppressClearOnEdit || (activeCellNode.innerHTML = ""), currentEditor = new n({ grid: self, gridPosition: absBox($container[0]), position: absBox(activeCellNode), container: activeCellNode, column: t, item: l || {}, commitChanges: commitEditAndSetFocus, cancelChanges: cancelEditAndSetFocus }), l && (currentEditor.loadValue(l), o && currentEditor.preClick && currentEditor.preClick()), serializedEditorValue = currentEditor.serializeValue(), currentEditor.position && handleActiveCellPositionChange() } else setFocus() } } } function commitEditAndSetFocus() { getEditorLock().commitCurrentEdit() && (setFocus(), options.autoEdit && navigateDown()) } function cancelEditAndSetFocus() { getEditorLock().cancelCurrentEdit() && setFocus() } function absBox(e) { var o = { top: e.offsetTop, left: e.offsetLeft, bottom: 0, right: 0, width: $(e).outerWidth(), height: $(e).outerHeight(), visible: !0 }; o.bottom = o.top + o.height, o.right = o.left + o.width; for (var t = e.offsetParent; (e = e.parentNode) != document.body && null != e;)o.visible && e.scrollHeight != e.offsetHeight && "visible" != $(e).css("overflowY") && (o.visible = o.bottom > e.scrollTop && o.top < e.scrollTop + e.clientHeight), o.visible && e.scrollWidth != e.offsetWidth && "visible" != $(e).css("overflowX") && (o.visible = o.right > e.scrollLeft && o.left < e.scrollLeft + e.clientWidth), o.left -= e.scrollLeft, o.top -= e.scrollTop, e === t && (o.left += e.offsetLeft, o.top += e.offsetTop, t = e.offsetParent), o.bottom = o.top + o.height, o.right = o.left + o.width; return o } function getActiveCellPosition() { return absBox(activeCellNode) } function getGridPosition() { return absBox($container[0]) } function handleActiveCellPositionChange() { if (activeCellNode && (trigger(self.onActiveCellPositionChanged, { grid: self }), currentEditor)) { var e = getActiveCellPosition(); currentEditor.show && currentEditor.hide && (e.visible ? currentEditor.show() : currentEditor.hide()), currentEditor.position && currentEditor.position(e) } } function getCellEditor() { return currentEditor } function getActiveCell() { return activeCellNode ? { row: activeRow, cell: activeCell, grid: self } : null } function getActiveCellNode() { return activeCellNode } function scrollRowIntoView(e, o) { var t = e * options.rowHeight, l = (e + 1) * options.rowHeight - viewportH + (viewportHasHScroll ? scrollbarDimensions.height : 0); (e + 1) * options.rowHeight > scrollTop + viewportH + offset ? (scrollTo(o ? t : l), render()) : e * options.rowHeight < scrollTop + offset && (scrollTo(o ? l : t), render()) } function scrollRowToTop(e) { scrollTo(e * options.rowHeight), render() } function scrollPage(e) { var o = e * numVisibleRows; if (scrollTo((getRowFromPosition(scrollTop) + o) * options.rowHeight), render(), options.enableCellNavigation && null != activeRow) { var t = activeRow + o, l = getDataLengthIncludingAddNew(); l <= t && (t = l - 1), t < 0 && (t = 0); for (var n = 0, r = null, i = activePosX; n <= activePosX;)canCellBeActive(t, n) && (r = n), n += getColspan(t, n); null !== r ? (setActiveCellInternal(getCellNode(t, r)), activePosX = i) : resetActiveCell() } } function navigatePageDown() { scrollPage(1) } function navigatePageUp() { scrollPage(-1) } function navigateTop() { navigateToRow(0) } function navigateBottom() { navigateToRow(getDataLength() - 1) } function navigateToRow(e) { var o = getDataLength(); if (!o) return !0; if (e < 0 ? e = 0 : o <= e && (e = o - 1), scrollCellIntoView(e, 0, !0), options.enableCellNavigation && null != activeRow) { for (var t = 0, l = null, n = activePosX; t <= activePosX;)canCellBeActive(e, t) && (l = t), t += getColspan(e, t); null !== l ? (setActiveCellInternal(getCellNode(e, l)), activePosX = n) : resetActiveCell() } return !0 } function getColspan(e, o) { var t = data.getItemMetadata && data.getItemMetadata(e); if (!t || !t.columns) return 1; var l = t.columns[columns[o].id] || t.columns[o], n = l && l.colspan; return n = "*" === n ? columns.length - o : n || 1 } function findFirstFocusableCell(e) { for (var o = 0; o < columns.length;) { if (canCellBeActive(e, o)) return o; o += getColspan(e, o) } return null } function findLastFocusableCell(e) { for (var o = 0, t = null; o < columns.length;)canCellBeActive(e, o) && (t = o), o += getColspan(e, o); return t } function gotoRight(e, o, t) { if (o >= columns.length) return null; for (; (o += getColspan(e, o)) < columns.length && !canCellBeActive(e, o);); return o < columns.length ? { row: e, cell: o, posX: o } : null } function gotoLeft(e, o, t) { if (o <= 0) return null; var l = findFirstFocusableCell(e); if (null === l || o <= l) return null; for (var n, r = { row: e, cell: l, posX: l }; ;) { if (!(n = gotoRight(r.row, r.cell, r.posX))) return null; if (n.cell >= o) return r; r = n } } function gotoDown(e, o, t) { for (var l, n = getDataLengthIncludingAddNew(); ;) { if (++e >= n) return null; for (l = o = 0; o <= t;)o += getColspan(e, l = o); if (canCellBeActive(e, l)) return { row: e, cell: l, posX: t } } } function gotoUp(e, o, t) { for (var l; ;) { if (--e < 0) return null; for (l = o = 0; o <= t;)o += getColspan(e, l = o); if (canCellBeActive(e, l)) return { row: e, cell: l, posX: t } } } function gotoNext(e, o, t) { if (null == e && null == o && canCellBeActive(e = o = t = 0, o)) return { row: e, cell: o, posX: o }; var l = gotoRight(e, o, t); if (l) return l; var n = null, r = getDataLengthIncludingAddNew(); for (e === r - 1 && e--; ++e < r;)if (null !== (n = findFirstFocusableCell(e))) return { row: e, cell: n, posX: n }; return null } function gotoPrev(e, o, t) { if (null == e && null == o && canCellBeActive(e = getDataLengthIncludingAddNew() - 1, o = t = columns.length - 1)) return { row: e, cell: o, posX: o }; for (var l, n; !l && !(l = gotoLeft(e, o, t));) { if (--e < 0) return null; o = 0, null !== (n = findLastFocusableCell(e)) && (l = { row: e, cell: n, posX: n }) } return l } function gotoRowStart(e, o, t) { var l = findFirstFocusableCell(e); return null === l ? null : { row: e, cell: l, posX: t } } function gotoRowEnd(e, o, t) { var l = findLastFocusableCell(e); return null === l ? null : { row: e, cell: l, posX: t } } function navigateRight() { return navigate("right") } function navigateLeft() { return navigate("left") } function navigateDown() { return navigate("down") } function navigateUp() { return navigate("up") } function navigateNext() { return navigate("next") } function navigatePrev() { return navigate("prev") } function navigateRowStart() { return navigate("home") } function navigateRowEnd() { return navigate("end") } function navigate(e) { if (!options.enableCellNavigation) return !1; if (!activeCellNode && "prev" != e && "next" != e) return !1; if (!getEditorLock().commitCurrentEdit()) return !0; setFocus(); tabbingDirection = { up: -1, down: 1, left: -1, right: 1, prev: -1, next: 1, home: -1, end: 1 }[e]; var o = (0, { up: gotoUp, down: gotoDown, left: gotoLeft, right: gotoRight, prev: gotoPrev, next: gotoNext, home: gotoRowStart, end: gotoRowEnd }[e])(activeRow, activeCell, activePosX); if (o) { var t = o.row == getDataLength(); return scrollCellIntoView(o.row, o.cell, !t), setActiveCellInternal(getCellNode(o.row, o.cell)), activePosX = o.posX, !0 } return setActiveCellInternal(getCellNode(activeRow, activeCell)), !1 } function getCellNode(e, o) { return rowsCache[e] ? (ensureCellNodesInRowsCache(e), rowsCache[e].cellNodesByColumnIdx[o]) : null } function setActiveCell(e, o, t, l, n) { initialized && (e > getDataLength() || e < 0 || o >= columns.length || o < 0 || options.enableCellNavigation && (scrollCellIntoView(e, o, !1), setActiveCellInternal(getCellNode(e, o), t, l, n))) } function canCellBeActive(e, o) { if (!options.enableCellNavigation || e >= getDataLengthIncludingAddNew() || e < 0 || o >= columns.length || o < 0) return !1; var t = data.getItemMetadata && data.getItemMetadata(e); if (t && void 0 !== t.focusable) return !!t.focusable; var l = t && t.columns; return l && l[columns[o].id] && void 0 !== l[columns[o].id].focusable ? !!l[columns[o].id].focusable : l && l[o] && void 0 !== l[o].focusable ? !!l[o].focusable : !!columns[o].focusable } function canCellBeSelected(e, o) { if (e >= getDataLength() || e < 0 || o >= columns.length || o < 0) return !1; var t = data.getItemMetadata && data.getItemMetadata(e); if (t && void 0 !== t.selectable) return !!t.selectable; var l = t && t.columns && (t.columns[columns[o].id] || t.columns[o]); return l && void 0 !== l.selectable ? !!l.selectable : !!columns[o].selectable } function gotoCell(e, o, t) { initialized && canCellBeActive(e, o) && getEditorLock().commitCurrentEdit() && (scrollCellIntoView(e, o, !1), setActiveCellInternal(getCellNode(e, o), t || e === getDataLength() || options.autoEdit), currentEditor || setFocus()) } function commitCurrentEdit() { var e = getDataItem(activeRow), o = columns[activeCell]; if (currentEditor) { if (currentEditor.isValueChanged()) { var t = currentEditor.validate(); if (t.valid) { if (activeRow < getDataLength()) { var l = { row: activeRow, cell: activeCell, editor: currentEditor, serializedValue: currentEditor.serializeValue(), prevSerializedValue: serializedEditorValue, execute: function () { this.editor.applyValue(e, this.serializedValue), updateRow(this.row), trigger(self.onCellChange, { row: this.row, cell: this.cell, item: e, grid: self }) }, undo: function () { this.editor.applyValue(e, this.prevSerializedValue), updateRow(this.row), trigger(self.onCellChange, { row: this.row, cell: this.cell, item: e, grid: self }) } }; options.editCommandHandler ? (makeActiveCellNormal(), options.editCommandHandler(e, o, l)) : (l.execute(), makeActiveCellNormal()) } else { var n = {}; currentEditor.applyValue(n, currentEditor.serializeValue()), makeActiveCellNormal(), trigger(self.onAddNewRow, { item: n, column: o, grid: self }) } return !getEditorLock().isActive() } return $(activeCellNode).removeClass("invalid"), $(activeCellNode).width(), $(activeCellNode).addClass("invalid"), trigger(self.onValidationError, { editor: currentEditor, cellNode: activeCellNode, validationResults: t, row: activeRow, cell: activeCell, column: o, grid: self }), currentEditor.focus(), !1 } makeActiveCellNormal() } return !0 } function cancelCurrentEdit() { return makeActiveCellNormal(), !0 } function rowsToRanges(e) { for (var o = [], t = columns.length - 1, l = 0; l < e.length; l++)o.push(new Slick.Range(e[l], 0, e[l], t)); return o } function getSelectedRows() { if (!selectionModel) throw new Error("Selection model is not set"); return selectedRows } function setSelectedRows(e) { if (!selectionModel) throw new Error("Selection model is not set"); selectionModel.setSelectedRanges(rowsToRanges(e)) } this.debug = function () { var e = ""; e += "\ncounter_rows_rendered:  " + counter_rows_rendered, e += "\ncounter_rows_removed:  " + counter_rows_removed, e += "\nrenderedRows:  " + renderedRows, e += "\nnumVisibleRows:  " + numVisibleRows, e += "\nmaxSupportedCssHeight:  " + maxSupportedCssHeight, e += "\nn(umber of pages):  " + n, e += "\n(current) page:  " + page, e += "\npage height (ph):  " + ph, e += "\nvScrollDir:  " + vScrollDir, alert(e) }, this.eval = function (expr) { return eval(expr) }, $.extend(this, { slickGridVersion: "2.3.12", onScroll: new Slick.Event, onSort: new Slick.Event, onHeaderMouseEnter: new Slick.Event, onHeaderMouseLeave: new Slick.Event, onHeaderContextMenu: new Slick.Event, onHeaderClick: new Slick.Event, onHeaderCellRendered: new Slick.Event, onBeforeHeaderCellDestroy: new Slick.Event, onHeaderRowCellRendered: new Slick.Event, onFooterRowCellRendered: new Slick.Event, onBeforeHeaderRowCellDestroy: new Slick.Event, onBeforeFooterRowCellDestroy: new Slick.Event, onMouseEnter: new Slick.Event, onMouseLeave: new Slick.Event, onClick: new Slick.Event, onDblClick: new Slick.Event, onContextMenu: new Slick.Event, onKeyDown: new Slick.Event, onAddNewRow: new Slick.Event, onBeforeAppendCell: new Slick.Event, onValidationError: new Slick.Event, onViewportChanged: new Slick.Event, onColumnsReordered: new Slick.Event, onColumnsResized: new Slick.Event, onCellChange: new Slick.Event, onBeforeEditCell: new Slick.Event, onBeforeCellEditorDestroy: new Slick.Event, onBeforeDestroy: new Slick.Event, onActiveCellChanged: new Slick.Event, onActiveCellPositionChanged: new Slick.Event, onDragInit: new Slick.Event, onDragStart: new Slick.Event, onDrag: new Slick.Event, onDragEnd: new Slick.Event, onSelectedRowsChanged: new Slick.Event, onCellCssStylesChanged: new Slick.Event, registerPlugin: registerPlugin, unregisterPlugin: unregisterPlugin, getColumns: getColumns, setColumns: setColumns, getColumnIndex: getColumnIndex, updateColumnHeader: updateColumnHeader, setSortColumn: setSortColumn, setSortColumns: setSortColumns, getSortColumns: getSortColumns, autosizeColumns: autosizeColumns, getOptions: getOptions, setOptions: setOptions, getData: getData, getDataLength: getDataLength, getDataItem: getDataItem, setData: setData, getSelectionModel: getSelectionModel, setSelectionModel: setSelectionModel, getSelectedRows: getSelectedRows, setSelectedRows: setSelectedRows, getContainerNode: getContainerNode, updatePagingStatusFromView: updatePagingStatusFromView, render: render, invalidate: invalidate, invalidateRow: invalidateRow, invalidateRows: invalidateRows, invalidateAllRows: invalidateAllRows, updateCell: updateCell, updateRow: updateRow, getViewport: getVisibleRange, getRenderedRange: getRenderedRange, resizeCanvas: resizeCanvas, updateRowCount: updateRowCount, scrollRowIntoView: scrollRowIntoView, scrollRowToTop: scrollRowToTop, scrollCellIntoView: scrollCellIntoView, scrollColumnIntoView: scrollColumnIntoView, getCanvasNode: getCanvasNode, getUID: getUID, getHeaderColumnWidthDiff: getHeaderColumnWidthDiff, getScrollbarDimensions: getScrollbarDimensions, getHeadersWidth: getHeadersWidth, getCanvasWidth: getCanvasWidth, focus: setFocus, scrollTo: scrollTo, getCellFromPoint: getCellFromPoint, getCellFromEvent: getCellFromEvent, getActiveCell: getActiveCell, setActiveCell: setActiveCell, getActiveCellNode: getActiveCellNode, getActiveCellPosition: getActiveCellPosition, resetActiveCell: resetActiveCell, editActiveCell: makeActiveCellEditable, getCellEditor: getCellEditor, getCellNode: getCellNode, getCellNodeBox: getCellNodeBox, canCellBeSelected: canCellBeSelected, canCellBeActive: canCellBeActive, navigatePrev: navigatePrev, navigateNext: navigateNext, navigateUp: navigateUp, navigateDown: navigateDown, navigateLeft: navigateLeft, navigateRight: navigateRight, navigatePageUp: navigatePageUp, navigatePageDown: navigatePageDown, navigateTop: navigateTop, navigateBottom: navigateBottom, navigateRowStart: navigateRowStart, navigateRowEnd: navigateRowEnd, gotoCell: gotoCell, getTopPanel: getTopPanel, setTopPanelVisibility: setTopPanelVisibility, getPreHeaderPanel: getPreHeaderPanel, setPreHeaderPanelVisibility: setPreHeaderPanelVisibility, setHeaderRowVisibility: setHeaderRowVisibility, getHeaderRow: getHeaderRow, getHeaderRowColumn: getHeaderRowColumn, setFooterRowVisibility: setFooterRowVisibility, getFooterRow: getFooterRow, getFooterRowColumn: getFooterRowColumn, getGridPosition: getGridPosition, flashCell: flashCell, addCellCssStyles: addCellCssStyles, setCellCssStyles: setCellCssStyles, removeCellCssStyles: removeCellCssStyles, getCellCssStyles: getCellCssStyles, init: finishInitialization, destroy: destroy, getEditorLock: getEditorLock, getEditController: getEditController }), init() } $.extend(!0, window, { Slick: { Grid: SlickGrid } }) }(jQuery);
/*--------------------*/
!function (X) { X.extend(!0, window, { Slick: { Data: { DataView: function (i) { var r, o, a, l, s, u = this, g = "id", c = [], f = [], p = {}, h = null, d = null, m = null, v = !1, _ = !0, w = {}, $ = {}, y = [], C = [], I = { getter: null, formatter: null, comparer: function (t, e) { return t.value === e.value ? 0 : t.value > e.value ? 1 : -1 }, predefinedValues: [], aggregators: [], aggregateEmpty: !1, aggregateCollapsed: !1, aggregateChildGroups: !1, collapsed: !1, displayTotalsRow: !0, lazyTotalsCalculation: !1 }, R = [], x = [], S = [], b = ":|:", M = 0, F = 0, A = 0, N = new Slick.Event, T = new Slick.Event, E = new Slick.Event; function G(t) { for (var e, n = t = t || 0, r = c.length; n < r; n++) { if (void 0 === (e = c[n][g])) throw new Error("Each data element must implement a unique 'id' property"); p[e] = n } } function k() { var t = M ? Math.max(1, Math.ceil(A / M)) : 1; return { pageSize: M, pageNum: F, totalRows: A, totalPages: t, dataView: u } } function t(t, e) { o = t, r = null, !1 === (_ = e) && c.reverse(), c.sort(t), !1 === e && c.reverse(), p = {}, G(), J() } function e(t, e) { _ = e, r = t, o = null; var n = Object.prototype.toString; Object.prototype.toString = "function" == typeof t ? t : function () { return this[t] }, !1 === e && c.reverse(), c.sort(), Object.prototype.toString = n, !1 === e && c.reverse(), p = {}, G(), J() } function j(t) { i.groupItemMetadataProvider || (i.groupItemMetadataProvider = new Slick.Data.GroupItemMetadataProvider), x = [], S = [], R = (t = t || []) instanceof Array ? t : [t]; for (var e = 0; e < R.length; e++) { var n = R[e] = X.extend(!0, {}, I, R[e]); n.getterIsAFn = "function" == typeof n.getter, n.compiledAccumulators = []; for (var r = n.aggregators.length; r--;)n.compiledAccumulators[r] = L(n.aggregators[r]); S[e] = {} } J() } function D() { if (!h) { h = {}; for (var t = 0, e = f.length; t < e; t++)h[f[t][g]] = t } } function n(t) { return c[p[t]] } function P(t, e) { if (void 0 === p[t] || t !== e[g]) throw new Error("Invalid or non-matching id"); c[p[t]] = e, (m = m || {})[t] = !0, J() } function z(t, e) { c.splice(t, 0, e), G(t), J() } function B(t) { if (!o) throw new Error("sortedAddItem() requires a sort comparer, use sort()"); z(function (t) { var e = 0, n = c.length; for (; e < n;) { var r = e + n >>> 1; -1 === o(c[r], t) ? e = 1 + r : n = r } return e }(t), t) } function V(t) { var e = p[t]; if (void 0 === e) throw new Error("Invalid id"); delete p[t], c.splice(e, 1), G(e), J() } function O(t, e) { if (null == t) for (var n = 0; n < R.length; n++)S[n] = {}, R[n].collapsed = e; else S[t] = {}, R[t].collapsed = e; J() } function K(t, e, n) { S[t][e] = R[t].collapsed ^ n, J() } function U(t) { var e, n = t.group, r = R[n.level], i = n.level == R.length, o = r.aggregators.length; if (!i && r.aggregateChildGroups) for (var a = n.groups.length; a--;)n.groups[a].totals.initialized || U(n.groups[a].totals); for (; o--;)(e = r.aggregators[o]).init(), !i && r.aggregateChildGroups ? r.compiledAccumulators[o].call(e, n.groups) : r.compiledAccumulators[o].call(e, n.rows), e.storeResult(t); t.initialized = !0 } function q(t) { var e = t.toString().match(/^function[^(]*\(([^)]*)\)\s*{([\s\S]*)}$/); return { params: e[1].split(","), body: e[2] } } function L(t) { var e = q(t.accumulate), n = new Function("_items", "for (var " + e.params[0] + ", _i=0, _il=_items.length; _i<_il; _i++) {" + e.params[0] + " = _items[_i]; " + e.body + "}"); return n.displayName = n.name = "compiledAccumulatorLoop", n } function H(t, e) { for (var n = [], r = 0, i = 0, o = t.length; i < o; i++)d(t[i], e) && (n[r++] = t[i]); return n } function Q(t, e, n) { for (var r, i = [], o = 0, a = 0, l = t.length; a < l; a++)r = t[a], n[a] ? i[o++] = r : d(r, e) && (i[o++] = r, n[a] = !0); return i } function W(t) { h = null, w.isFilterNarrowing == $.isFilterNarrowing && w.isFilterExpanding == $.isFilterExpanding || (C = []); var e = function (t) { if (d) { var e = i.inlineFilters ? l : H, n = i.inlineFilters ? s : Q; w.isFilterNarrowing ? y = e(y, a) : w.isFilterExpanding ? y = n(t, a, C) : w.isFilterUnchanged || (y = e(t, a)) } else y = M ? t : t.concat(); var r; return r = M ? (y.length <= F * M && (F = 0 === y.length ? 0 : Math.floor((y.length - 1) / M)), y.slice(M * F, M * F + M)) : y, { totalRows: y.length, rows: r } }(t); A = e.totalRows; var n = e.rows; x = [], R.length && (x = function t(e, n) { for (var r, i, o, a = [], l = {}, s = n ? n.level + 1 : 0, u = R[s], g = 0, c = u.predefinedValues.length; g < c; g++)(r = l[i = u.predefinedValues[g]]) || ((r = new Slick.Group).value = i, r.level = s, r.groupingKey = (n ? n.groupingKey + b : "") + i, a[a.length] = r, l[i] = r); for (g = 0, c = e.length; g < c; g++)o = e[g], (r = l[i = u.getterIsAFn ? u.getter(o) : o[u.getter]]) || ((r = new Slick.Group).value = i, r.level = s, r.groupingKey = (n ? n.groupingKey + b : "") + i, a[a.length] = r, l[i] = r), r.rows[r.count++] = o; if (s < R.length - 1) for (g = 0; g < a.length; g++)(r = a[g]).groups = t(r.rows, r); return a.sort(R[s].comparer), a }(n)).length && (function t(e, n) { for (var r, i, o, a, l = R[n = n || 0], s = l.collapsed, u = S[n], g = e.length; g--;)(r = e[g]).collapsed && !l.aggregateCollapsed || (r.groups && t(r.groups, n + 1), l.aggregators.length && (l.aggregateEmpty || r.rows.length || r.groups && r.groups.length) && (a = void 0, o = R[(i = r).level], ((a = new Slick.GroupTotals).group = i).totals = a, o.lazyTotalsCalculation || U(a)), r.collapsed = s ^ u[r.groupingKey], r.title = l.formatter ? l.formatter(r) : r.value) }(x), n = function t(e, n) { for (var r, i, o = R[n = n || 0], a = [], l = 0, s = 0, u = e.length; s < u; s++) { if (i = e[s], !(a[l++] = i).collapsed) for (var g = 0, c = (r = i.groups ? t(i.groups, n + 1) : i.rows).length; g < c; g++)a[l++] = r[g]; i.totals && o.displayTotalsRow && (!i.collapsed || o.aggregateCollapsed) && (a[l++] = i.totals) } return a }(x)); var r = function (t, e) { var n, r, i, o = [], a = 0, l = e.length; w && w.ignoreDiffsBefore && (a = Math.max(0, Math.min(e.length, w.ignoreDiffsBefore))), w && w.ignoreDiffsAfter && (l = Math.min(e.length, Math.max(0, w.ignoreDiffsAfter))); for (var s = a, u = t.length; s < l; s++)u <= s ? o[o.length] = s : (n = e[s], r = t[s], (R.length && (i = n.__nonDataRow || r.__nonDataRow) && n.__group !== r.__group || n.__group && !n.equals(r) || i && (n.__groupTotals || r.__groupTotals) || n[g] != r[g] || m && m[n[g]]) && (o[o.length] = s)); return o }(f, n); return f = n, r } function J() { if (!v) { var t = f.length, e = A, n = W(c); M && A < F * M && (F = Math.max(0, Math.ceil(A / M) - 1), n = W(c)), m = null, $ = w, w = {}, e !== A && E.notify(k(), null, u), t !== f.length && N.notify({ previous: t, current: f.length, dataView: u }, null, u), 0 < n.length && T.notify({ rows: n, dataView: u }, null, u) } } i = X.extend(!0, {}, { groupItemMetadataProvider: null, inlineFilters: !1 }, i), X.extend(this, { beginUpdate: function () { v = !0 }, endUpdate: function () { v = !1, J() }, setPagingOptions: function (t) { null != t.pageSize && (M = t.pageSize, F = M ? Math.min(F, Math.max(0, Math.ceil(A / M) - 1)) : 0), null != t.pageNum && (F = Math.min(t.pageNum, Math.max(0, Math.ceil(A / M) - 1))), E.notify(k(), null, u), J() }, getPagingInfo: k, getItems: function () { return c }, setItems: function (t, e) { void 0 !== e && (g = e), c = y = t, p = {}, G(), J() }, setFilter: function (t) { d = t, i.inlineFilters && (l = function () { var t = q(d), e = "{ continue _coreloop; }$1", n = "{ _retval[_idx++] = $item$; continue _coreloop; }$1", r = t.body.replace(/return false\s*([;}]|\}|$)/gi, e).replace(/return!1([;}]|\}|$)/gi, e).replace(/return true\s*([;}]|\}|$)/gi, n).replace(/return!0([;}]|\}|$)/gi, n).replace(/return ([^;}]+?)\s*([;}]|$)/gi, "{ if ($1) { _retval[_idx++] = $item$; }; continue _coreloop; }$2"), i = ["var _retval = [], _idx = 0; ", "var $item$, $args$ = _args; ", "_coreloop: ", "for (var _i = 0, _il = _items.length; _i < _il; _i++) { ", "$item$ = _items[_i]; ", "$filter$; ", "} ", "return _retval; "].join(""); i = (i = (i = i.replace(/\$filter\$/gi, r)).replace(/\$item\$/gi, t.params[0])).replace(/\$args\$/gi, t.params[1]); var o = new Function("_items,_args", i); return o.displayName = o.name = "compiledFilter", o }(), s = function () { var t = q(d), e = "{ continue _coreloop; }$1", n = "{ _cache[_i] = true;_retval[_idx++] = $item$; continue _coreloop; }$1", r = t.body.replace(/return false\s*([;}]|\}|$)/gi, e).replace(/return!1([;}]|\}|$)/gi, e).replace(/return true\s*([;}]|\}|$)/gi, n).replace(/return!0([;}]|\}|$)/gi, n).replace(/return ([^;}]+?)\s*([;}]|$)/gi, "{ if ((_cache[_i] = $1)) { _retval[_idx++] = $item$; }; continue _coreloop; }$2"), i = ["var _retval = [], _idx = 0; ", "var $item$, $args$ = _args; ", "_coreloop: ", "for (var _i = 0, _il = _items.length; _i < _il; _i++) { ", "$item$ = _items[_i]; ", "if (_cache[_i]) { ", "_retval[_idx++] = $item$; ", "continue _coreloop; ", "} ", "$filter$; ", "} ", "return _retval; "].join(""); i = (i = (i = i.replace(/\$filter\$/gi, r)).replace(/\$item\$/gi, t.params[0])).replace(/\$args\$/gi, t.params[1]); var o = new Function("_items,_args,_cache", i); return o.displayName = o.name = "compiledFilterWithCaching", o }()), J() }, getFilter: function () { return d }, getFilteredItems: function () { return y }, sort: t, fastSort: e, reSort: function () { o ? t(o, _) : r && e(r, _) }, setGrouping: j, getGrouping: function () { return R }, groupBy: function (t, e, n) { j(null != t ? { getter: t, formatter: e, comparer: n } : []) }, setAggregators: function (t, e) { if (!R.length) throw new Error("At least one grouping must be specified before calling setAggregators()."); R[0].aggregators = t, R[0].aggregateCollapsed = e, j(R) }, collapseAllGroups: function (t) { O(t, !0) }, expandAllGroups: function (t) { O(t, !1) }, collapseGroup: function (t) { var e = Array.prototype.slice.call(arguments), n = e[0]; 1 == e.length && -1 != n.indexOf(b) ? K(n.split(b).length - 1, n, !0) : K(e.length - 1, e.join(b), !0) }, expandGroup: function (t) { var e = Array.prototype.slice.call(arguments), n = e[0]; 1 == e.length && -1 != n.indexOf(b) ? K(n.split(b).length - 1, n, !1) : K(e.length - 1, e.join(b), !1) }, getGroups: function () { return x }, getIdxById: function (t) { return p[t] }, getRowByItem: function (t) { return D(), h[t[g]] }, getRowById: function (t) { return D(), h[t] }, getItemById: n, getItemByIdx: function (t) { return c[t] }, mapItemsToRows: function (t) { var e = []; D(); for (var n = 0, r = t.length; n < r; n++) { var i = h[t[n][g]]; null != i && (e[e.length] = i) } return e }, mapRowsToIds: function (t) { for (var e = [], n = 0, r = t.length; n < r; n++)t[n] < f.length && (e[e.length] = f[t[n]][g]); return e }, mapIdsToRows: function (t) { var e = []; D(); for (var n = 0, r = t.length; n < r; n++) { var i = h[t[n]]; null != i && (e[e.length] = i) } return e }, setRefreshHints: function (t) { w = t }, setFilterArgs: function (t) { a = t }, refresh: J, updateItem: P, insertItem: z, addItem: function (t) { c.push(t), G(c.length - 1), J() }, sortedAddItem: B, sortedUpdateItem: function (t) { if (!o) throw new Error("sortedUpdateItem() requires a sort comparer, use sort()"); var e = n(t.id); 0 !== o(e, t) ? (V(t.id), B(t)) : P(t.id, t) }, deleteItem: V, syncGridSelection: function (r, e, i) { var o, a = this, l = a.mapRowsToIds(r.getSelectedRows()), n = new Slick.Event; function s(t) { l.join(",") != t.join(",") && (l = t, n.notify({ grid: r, ids: l, dataView: a }, new Slick.EventData, a)) } function t() { if (0 < l.length) { o = !0; var t = a.mapIdsToRows(l); e || s(a.mapRowsToIds(t)), r.setSelectedRows(t), o = !1 } } return r.onSelectedRowsChanged.subscribe(function (t, e) { if (!o) { var n = a.mapRowsToIds(r.getSelectedRows()); if (i && r.getOptions().multiSelect) s(X.grep(l, function (t) { return void 0 === a.getRowById(t) }).concat(n)); else s(n) } }), this.onRowsChanged.subscribe(t), this.onRowCountChanged.subscribe(t), n }, syncGridCellCssStyles: function (r, i) { var o, a; function n(t) { for (var e in o = {}, t) { var n = f[e][g]; o[n] = t[e] } } function l() { if (o) { a = !0, D(); var t = {}; for (var e in o) { var n = h[e]; null != n && (t[n] = o[e]) } r.setCellCssStyles(i, t), a = !1 } } n(r.getCellCssStyles(i)), r.onCellCssStylesChanged.subscribe(function (t, e) { a || i == e.key && (e.hash ? n(e.hash) : (r.onCellCssStylesChanged.unsubscribe(styleChanged), u.onRowsChanged.unsubscribe(l), u.onRowCountChanged.unsubscribe(l))) }), this.onRowsChanged.subscribe(l), this.onRowCountChanged.subscribe(l) }, getLength: function () { return f.length }, getItem: function (t) { var e = f[t]; if (e && e.__group && e.totals && !e.totals.initialized) { var n = R[e.level]; n.displayTotalsRow || (U(e.totals), e.title = n.formatter ? n.formatter(e) : e.value) } else e && e.__groupTotals && !e.initialized && U(e); return e }, getItemMetadata: function (t) { var e = f[t]; return void 0 === e ? null : e.__group ? i.groupItemMetadataProvider.getGroupRowMetadata(e) : e.__groupTotals ? i.groupItemMetadataProvider.getTotalsRowMetadata(e) : null }, onRowCountChanged: N, onRowsChanged: T, onPagingInfoChanged: E }) }, Aggregators: { Avg: function (t) { this.field_ = t, this.init = function () { this.count_ = 0, this.nonNullCount_ = 0, this.sum_ = 0 }, this.accumulate = function (t) { var e = t[this.field_]; this.count_++ , null == e || "" === e || isNaN(e) || (this.nonNullCount_++ , this.sum_ += parseFloat(e)) }, this.storeResult = function (t) { t.avg || (t.avg = {}), 0 != this.nonNullCount_ && (t.avg[this.field_] = this.sum_ / this.nonNullCount_) } }, Min: function (t) { this.field_ = t, this.init = function () { this.min_ = null }, this.accumulate = function (t) { var e = t[this.field_]; null == e || "" === e || isNaN(e) || (null == this.min_ || e < this.min_) && (this.min_ = e) }, this.storeResult = function (t) { t.min || (t.min = {}), t.min[this.field_] = this.min_ } }, Max: function (t) { this.field_ = t, this.init = function () { this.max_ = null }, this.accumulate = function (t) { var e = t[this.field_]; null == e || "" === e || isNaN(e) || (null == this.max_ || e > this.max_) && (this.max_ = e) }, this.storeResult = function (t) { t.max || (t.max = {}), t.max[this.field_] = this.max_ } }, Sum: function (t) { this.field_ = t, this.init = function () { this.sum_ = null }, this.accumulate = function (t) { var e = t[this.field_]; null == e || "" === e || isNaN(e) || (this.sum_ += parseFloat(e)) }, this.storeResult = function (t) { t.sum || (t.sum = {}), t.sum[this.field_] = this.sum_ } } } } } }) }(jQuery);
/*-------------------------------------------------------*/
!function (u) { u.extend(!0, window, { Slick: { Editors: { Text: function (n) { var l, o; this.init = function () { (l = u("<INPUT type=text class='editor-text textEditor' />").appendTo(n.container).bind("keydown.nav", function (e) { e.keyCode !== u.ui.keyCode.LEFT && e.keyCode !== u.ui.keyCode.RIGHT || e.stopImmediatePropagation() }).focus().select()).blur(function () { Slick.GlobalEditorLock.isActive() && Slick.GlobalEditorLock.commitCurrentEdit() }) }, this.destroy = function () { l.remove() }, this.focus = function () { l.focus() }, this.getValue = function () { return l.val() }, this.setValue = function (e) { l.val(e) }, this.loadValue = function (e) { if (-1 != n.column.field.indexOf(".")) { var t = n.column.field.split("."), i = e[t[0]]; i && (o = i[t[1]]) } else o = e[n.column.field]; l.val(o), l[0].defaultValue = o, l.select() }, this.serializeValue = function () { return l.val() }, this.applyValue = function (e, t) { if (o != t) { if (-1 != n.column.field.indexOf(".")) { var i = n.column.field.split("."); e[i[0]] || (e[i[0]] = {}), e[i[0]][i[1]] = t } else e[n.column.field] = t; e.slickRowState || (e.slickRowState = "update") } }, this.isValueChanged = function () { return !("" == l.val() && null == o) && l.val() != o }, this.validate = function () { if (n.column.validator) { var e = n.column.validator(l.val()); if (!e.valid) return e } return { valid: !0, msg: null } }, this.init() }, Integer: function (o) { var l, a, c = o.column.opt, e = !1, t = o.item; t && t.fieldPermission && (t.fieldPermission[capitalizeText(o.column.field)] && t.fieldPermission[capitalizeText(o.column.field)].update || (e = !0)); if (e) return; this.init = function (e) { (l = u("<INPUT name='quantity min='0' class='editor-text numberEditor' />")).bind("keydown.nav", function (e) { e.keyCode !== u.ui.keyCode.LEFT && e.keyCode !== u.ui.keyCode.RIGHT || e.stopImmediatePropagation() }), l.appendTo(o.container), l.focus().select(), l.keydown(function (e) { var t = l.val(), i = c ? c.min : null, n = c ? c.max : null; "38" == e.keyCode ? (t++ , (null == n || t <= n) && l.val(t), e.stopPropagation()) : "40" == e.keyCode && (t-- , (null == i || i <= t) && l.val(t), e.stopPropagation()) }), l.blur(function () { Slick.GlobalEditorLock.isActive() && Slick.GlobalEditorLock.commitCurrentEdit() }) }, this.destroy = function () { l.remove() }, this.focus = function () { l.focus() }, this.loadValue = function (e) { if (-1 != o.column.field.indexOf(".")) { var t = o.column.field.split("."), i = e[t[0]]; i && (a = i[t[1]]) } else a = e[o.column.field]; l.val(a), l[0].defaultValue = a, l.select() }, this.serializeValue = function () { return parseInt(l.val(), 10) || 0 }, this.applyValue = function (e, t) { if (a != t) { var i = c ? c.min : null, n = c ? c.max : null; if (null != i && t < i || null != n && n < t) return; if (-1 != o.column.field.indexOf(".")) { var l = o.column.field.split("."); e[l[0]] || (e[l[0]] = {}), e[l[0]][l[1]] = t } else e[o.column.field] = t; e.slickRowState || (e.slickRowState = "update") } }, this.isValueChanged = function () { return !("" == l.val() && null == a) && l.val() != a }, this.validate = function () { return isNaN(l.val()) ? { valid: !1, msg: "Please enter a valid integer" } : { valid: !0, msg: null } }, this.init() }, Date: function (l) { var n, o; this.init = function () { u('<div class="input-group date"><INPUT type="text" class="editor-text dateEditor"/><div class="input-group-addon"><span class="bowtie-icon bowtie-calendar"></span></div></div>').appendTo(l.container), n = u(".dateEditor"); var e = moment().locale(keyLang).localeData()._longDateFormat.l; e ? e = e.toLowerCase().replace("ddd", "D").replace("mmm", "M") : "vn" != keyLang || (e = "dd/mm/yyyy"), n.datepicker({ autoclose: !0, todayHighlight: !0, showOnFocus: !0, format: e }), n.width(n.width() - 18), u(".slick-row .input-group .input-group-addon").click(function () { n.focus() }), n.focus().select() }, this.destroy = function () { u.datepicker.dpDiv.stop(!0, !0), n.datepicker("hide"), n.datepicker("destroy"), n.remove() }, this.show = function () { 0 }, this.hide = function () { 0 }, this.position = function (e) { }, this.focus = function () { n.focus() }, this.loadValue = function (e) { if (-1 != l.column.field.indexOf(".")) { var t = l.column.field.split("."), i = e[t[0]]; i && (o = i[t[1]]) } else o = e[l.column.field] || ""; n.defaultValue = o, n.datepicker("update", moment(o).format("l")), n.select() }, this.serializeValue = function () { return n.val() }, this.applyValue = function (e, t) { var i = moment(t, "l").format(); if (o != i) { if (-1 != l.column.field.indexOf(".")) { var n = l.column.field.split("."); e[n[0]] || (e[n[0]] = {}), e[n[0]][n[1]] = i } else e[l.column.field] = i; e.slickRowState || (e.slickRowState = "update") } }, this.isValueChanged = function () { return !("" == n.val() && null == n.defaultValue) && n.val() != n.defaultValue }, this.validate = function () { return { valid: !0, msg: null } }, this.init() }, YesNoSelect: function (i) { var t, n; this.init = function () { (t = u("<SELECT tabIndex='0' class='editor-yesno'><OPTION value='yes'>Yes</OPTION><OPTION value='no'>No</OPTION></SELECT>")).appendTo(i.container), t.focus() }, this.destroy = function () { t.remove() }, this.focus = function () { t.focus() }, this.loadValue = function (e) { t.val((n = e[i.column.field]) ? "yes" : "no"), t.select() }, this.serializeValue = function () { return "yes" == t.val() }, this.applyValue = function (e, t) { e[i.column.field] != t && (e[i.column.field] = t, e.slickRowState || (e.slickRowState = "update")) }, this.isValueChanged = function () { return t.val() != n }, this.validate = function () { return { valid: !0, msg: null } }, this.init() }, Checkbox: function (n) { var l, o; this.init = function () { (l = u("<INPUT type=checkbox value='true' class='editor-checkbox' hideFocus>")).appendTo(n.container), l.focus(), l.change(function () { Slick.GlobalEditorLock.isActive() && Slick.GlobalEditorLock.commitCurrentEdit() }) }, this.destroy = function () { l.remove() }, this.focus = function () { l.focus() }, this.loadValue = function (e) { if (o = !!e[n.column.field], -1 != n.column.field.indexOf(".")) { var t = n.column.field.split("."), i = e[t[0]]; i && (o = i[t[1]]) } else o = e[n.column.field]; o ? l.prop("checked", !0) : l.prop("checked", !1) }, this.serializeValue = function () { return l.prop("checked") }, this.applyValue = function (e, t) { if (o != t) { if (-1 != n.column.field.indexOf(".")) { var i = n.column.field.split("."); e[i[0]] || (e[i[0]] = {}), e[i[0]][i[1]] = t } else e[n.column.field] = t; e.slickRowState || (e.slickRowState = "update") } }, this.isValueChanged = function () { return this.serializeValue() !== o }, this.validate = function () { return { valid: !0, msg: null } }, this.init() }, PercentComplete: function (n) { var l, t, o; this.init = function () { (l = u("<INPUT type=text class='editor-percentcomplete' />")).width(u(n.container).innerWidth() - 25), l.appendTo(n.container), (t = u("<div class='editor-percentcomplete-picker' />").appendTo(n.container)).append("<div class='editor-percentcomplete-helper'><div class='editor-percentcomplete-wrapper'><div class='editor-percentcomplete-slider' /><div class='editor-percentcomplete-buttons' /></div></div>"), t.find(".editor-percentcomplete-buttons").append("<button val=0>Not started</button><br/><button val=50>In Progress</button><br/><button val=100>Complete</button>"), l.focus().select(), t.find(".editor-percentcomplete-slider").slider({ orientation: "vertical", range: "min", value: o, slide: function (e, t) { l.val(t.value) } }), t.find(".editor-percentcomplete-buttons button").bind("click", function (e) { l.val(u(this).attr("val")), t.find(".editor-percentcomplete-slider").slider("value", u(this).attr("val")) }) }, this.destroy = function () { l.remove(), t.remove() }, this.focus = function () { l.focus() }, this.loadValue = function (e) { if (-1 != n.column.field.indexOf(".")) { var t = n.column.field.split("."), i = e[t[0]]; i && (o = i[t[1]]) } else o = e[n.column.field]; l.val(o), l.select() }, this.serializeValue = function () { return parseInt(l.val(), 10) || 0 }, this.applyValue = function (e, t) { if (o != t) { if (-1 != n.column.field.indexOf(".")) { var i = n.column.field.split("."); e[i[0]] || (e[i[0]] = {}), e[i[0]][i[1]] = t } else e[n.column.field] = t; e.slickRowState || (e.slickRowState = "update") } }, this.isValueChanged = function () { return !("" == l.val() && null == o) && (parseInt(l.val(), 10) || 0) != o }, this.validate = function () { return isNaN(parseInt(l.val(), 10)) ? { valid: !1, msg: "Please enter a valid positive number" } : { valid: !0, msg: null } }, this.init() }, LongText: function (n) { var l, t, o, i = this; this.init = function () { var e = u("body"); t = u("<DIV style='z-index:10000;position:absolute;background:white;padding:5px;border:3px solid gray; -moz-border-radius:10px; border-radius:10px;'/>").appendTo(e), l = u("<TEXTAREA hidefocus rows=5 style='backround:white;width:250px;height:80px;border:0;outline:0'>").appendTo(t), u("<DIV style='text-align:right'><BUTTON>Save</BUTTON><BUTTON>Cancel</BUTTON></DIV>").appendTo(t), t.find("button:first").bind("click", this.save), t.find("button:last").bind("click", this.cancel), l.bind("keydown", this.handleKeyDown), i.position(n.position), l.focus().select() }, this.handleKeyDown = function (e) { e.which == u.ui.keyCode.ENTER && e.ctrlKey ? i.save() : e.which == u.ui.keyCode.ESCAPE ? (e.preventDefault(), i.cancel()) : e.which == u.ui.keyCode.TAB && e.shiftKey ? (e.preventDefault(), n.grid.navigatePrev()) : e.which == u.ui.keyCode.TAB && (e.preventDefault(), n.grid.navigateNext()) }, this.save = function () { n.commitChanges() }, this.cancel = function () { l.val(o), n.cancelChanges() }, this.hide = function () { t.hide() }, this.show = function () { t.show() }, this.position = function (e) { t.css("top", e.top - 5).css("left", e.left - 5) }, this.destroy = function () { t.remove() }, this.focus = function () { l.focus() }, this.loadValue = function (e) { if (-1 != n.column.field.indexOf(".")) { var t = n.column.field.split("."), i = e[t[0]]; i && (o = i[t[1]]) } else o = e[n.column.field]; l.val(o), l.select() }, this.serializeValue = function () { return l.val() }, this.applyValue = function (e, t) { if (o != t) { if (-1 != n.column.field.indexOf(".")) { var i = n.column.field.split("."); e[i[0]] || (e[i[0]] = {}), e[i[0]][i[1]] = t } else e[n.column.field] = t; e.slickRowState || (e.slickRowState = "update") } }, this.isValueChanged = function () { return !("" == l.val() && null == o) && l.val() != o }, this.validate = function () { return { valid: !0, msg: null } }, this.init() }, Combobox: function (l) { var o, a; this.keyCaptureList = [Slick.keyCode.UP, Slick.keyCode.DOWN, Slick.keyCode.ENTER], this.init = function () { if ((o = u('<select class="gridSelectWrapper"></select>')).width(l.container.clientWidth + 3), o.appendTo(l.container), o.focus().select(), l.column.comboboxSetting) { var t = null; l.item && (t = l.item[l.column.field]); var e = l.column.comboboxSetting.param; e.currentId = t, u.ajax({ url: l.column.comboboxSetting.url, data: e, type: "POST", dataType: "json", async: !1, contentType: "application/x-www-form-urlencoded; charset=utf-8", success: function (e) { l.column.dataSource = e.data } }), o.select2({ placeholder: "-", allowClear: !0, dropdownAutoWidth: !0, templateResult: l.column.formatState, data: l.column.dataSource, ajax: { delay: 250, url: l.column.comboboxSetting.url, type: "POST", async: !1, dataType: "json", contentType: "application/x-www-form-urlencoded; charset=utf-8", data: function (e) { return l.column.comboboxSetting.param.searchValue = e.term, l.column.comboboxSetting.param.currentId = t, l.column.comboboxSetting.param }, processResults: function (e) { return e.isError ? l.column.dataSource = [] : l.column.dataSource = e.data, l.column.comboboxSetting.addHeader && l.column.dataSource.splice(0, 0, { id: "header", disabled: !0 }), { results: l.column.dataSource } } } }) } else { var i = null; if (l.column.dataSource && 0 < l.column.dataSource.length) i = "object" == typeof l.column.dataSource[0].text ? l.column.dataSource.map(function (e) { return { id: e.id, text: e.text[keyLang] } }) : l.column.dataSource; o.select2({ placeholder: "-", allowClear: !0, dropdownAutoWidth: !0, data: i, matcher: function (l, e) { if ("" === u.trim(l.term)) return e; if ("header" == e.id) return e; if (void 0 === e.text) return null; var o = !1; return u.each(e, function (e, t) { if ("element" == e || "disabled" == e || "selected" == e) return !0; if ("string" != typeof t) return !0; var i = t.toLowerCase(), n = l.term.toLowerCase(); return -1 < i.indexOf(n) ? !(o = !0) : void 0 }), o ? e : null }, templateResult: l.column.formatState }) } o.on("select2:close", function () { Slick.GlobalEditorLock.isActive() && Slick.GlobalEditorLock.commitCurrentEdit() }) }, this.destroy = function () { o.select2("destroy"), o.remove() }, this.show = function () { }, this.hide = function () { o.select2("results_hide") }, this.position = function (e) { }, this.focus = function () { o.select2("input_focus") }, this.loadValue = function (e) { if (-1 != l.column.field.indexOf(".")) { var t = l.column.field.split("."), i = e[t[0]]; i && (a = i[t[1]]) } else a = e[l.column.field]; o.val(a), o[0].defaultValue = a, o.trigger("change.select2") }, this.serializeValue = function () { return o.val() }, this.applyValue = function (e, t) { if (a != t) { if (-1 != l.column.field.indexOf(".")) { var i = l.column.field.split("."); e[i[0]] || (e[i[0]] = {}), e[i[0]][i[1]] = t } else if (e[l.column.field] = t, l.column.comboboxSetting && l.column.comboboxSetting.relateColumn) { var n = o.select2("data"); e[l.column.comboboxSetting.relateColumn] = n[0] } e.slickRowState || (e.slickRowState = "update") } }, this.isValueChanged = function () { return !("" == o.val() && null == a) && o.val() != a }, this.validate = function () { return { valid: !0, msg: null } }, this.formatter = function (e, t, i, n, l) { return n.dataSource[i] || "-" }, this.populateSelect = function (i, e, t) { var n; t && i.appendChild(new Option("", "")), u.each(e, function (e, t) { n = new Option(t.text, t.id), i.appendChild(n) }) }, this.init() }, ObjectValue: function (e, t) { if (!e) return null; var i = null; if (-1 != t.field.indexOf(".")) { var n = t.field.split("."), l = e[n[0]]; l && (i = l[n[1]]) } else i = e[t.field]; return i } } } }) }(jQuery);
/*------------------------------*/
!function (a) { a.extend(!0, window, { Slick: { CheckboxSelectColumn: function (e) { var l, t = new Slick.EventHandler, r = {}, d = a.extend(!0, {}, { columnId: "_checkbox_selector", cssClass: null, toolTip: "Select/Deselect All", width: 30 }, e); function o(e, t) { var o, i, n = l.getSelectedRows(), c = {}; for (i = 0; i < n.length; i++)c[o = n[i]] = !0, c[o] !== r[o] && (l.invalidateRow(o), delete r[o]); for (i in r) l.invalidateRow(i); r = c, l.render(), n.length && n.length == l.getDataLength() ? l.updateColumnHeader(d.columnId, "<input type='checkbox' checked='checked'>", d.toolTip) : l.updateColumnHeader(d.columnId, "<input type='checkbox'>", d.toolTip) } function i(e, t) { 32 == e.which && l.getColumns()[t.cell].id === d.columnId && (l.getEditorLock().isActive() && !l.getEditorLock().commitCurrentEdit() || c(t.row), e.preventDefault(), e.stopImmediatePropagation()) } function n(e, t) { if (l.getColumns()[t.cell].id === d.columnId && a(e.target).is(":checkbox")) { if (l.getEditorLock().isActive() && !l.getEditorLock().commitCurrentEdit()) return e.preventDefault(), void e.stopImmediatePropagation(); c(t.row), e.stopPropagation(), e.stopImmediatePropagation() } } function c(t) { r[t] ? l.setSelectedRows(a.grep(l.getSelectedRows(), function (e) { return e != t })) : l.setSelectedRows(l.getSelectedRows().concat(t)) } function s(e, t) { if (t.column.id == d.columnId && a(e.target).is(":checkbox")) { if (l.getEditorLock().isActive() && !l.getEditorLock().commitCurrentEdit()) return e.preventDefault(), void e.stopImmediatePropagation(); if (a(e.target).is(":checked")) { for (var o = [], i = 0; i < l.getDataLength(); i++)o.push(i); l.setSelectedRows(o) } else l.setSelectedRows([]); e.stopPropagation(), e.stopImmediatePropagation() } } function u(e, t, o, i, n) { return n ? r[e] ? "<input type='checkbox' checked='checked'>" : "<input type='checkbox'>" : null } a.extend(this, { init: function (e) { l = e, t.subscribe(l.onSelectedRowsChanged, o).subscribe(l.onClick, n).subscribe(l.onHeaderClick, s).subscribe(l.onKeyDown, i) }, destroy: function () { t.unsubscribeAll() }, getColumnDefinition: function () { return { id: d.columnId, name: "<input type='checkbox'>", toolTip: d.toolTip, field: "sel", width: d.width, resizable: !1, sortable: !1, cssClass: d.cssClass, formatter: u } } }) } } }) }(jQuery);
/*----------------------------------*/
!function (u) { u.extend(!0, window, { Slick: { CellRangeSelector: function (n) { var l, r, a, i, c = this, t = new Slick.EventHandler, o = { selectionCss: { border: "2px dashed blue" } }; function s(e, n) { e.stopImmediatePropagation() } function g(e, n) { var t = l.getCellFromEvent(e); if (!1 !== c.onBeforeCellRangeSelected.notify(t) && l.canCellBeSelected(t.row, t.cell) && (a = !0, e.stopImmediatePropagation()), a) { l.focus(); var o = l.getCellFromPoint(n.startX - u(r).offset().left, n.startY - u(r).offset().top); return n.range = { start: o, end: {} }, i.show(new Slick.Range(o.row, o.cell)) } } function d(e, n) { if (a) { e.stopImmediatePropagation(); var t = l.getCellFromPoint(e.pageX - u(r).offset().left, e.pageY - u(r).offset().top); l.canCellBeSelected(t.row, t.cell) && (n.range.end = t, i.show(new Slick.Range(n.range.start.row, n.range.start.cell, t.row, t.cell))) } } function f(e, n) { a && (a = !1, e.stopImmediatePropagation(), i.hide(), c.onCellRangeSelected.notify({ range: new Slick.Range(n.range.start.row, n.range.start.cell, n.range.end.row, n.range.end.cell) })) } u.extend(this, { init: function (e) { n = u.extend(!0, {}, o, n), i = new Slick.CellRangeDecorator(e, n), r = (l = e).getCanvasNode(), t.subscribe(l.onDragInit, s).subscribe(l.onDragStart, g).subscribe(l.onDrag, d).subscribe(l.onDragEnd, f) }, destroy: function () { t.unsubscribeAll() }, onBeforeCellRangeSelected: new Slick.Event, onCellRangeSelected: new Slick.Event }) } } }) }(jQuery);

/*-------------------------------------*/
!function (d) { d.extend(!0, window, { Slick: { CellRangeDecorator: function (s, l) { var n; l = d.extend(!0, {}, { selectionCssClass: "slick-range-decorator", selectionCss: { zIndex: "9999", border: "2px dashed red" } }, l), d.extend(this, { show: function (e) { n = n || d("<div></div>", { css: l.selectionCss }).addClass(l.selectionCssClass).css("position", "absolute").appendTo(s.getCanvasNode()); var o = s.getCellNodeBox(e.fromRow, e.fromCell), t = s.getCellNodeBox(e.toRow, e.toCell); return n.css({ top: o.top - 1, left: o.left - 1, height: t.bottom - o.top - 2, width: t.right - o.left - 2 }), n }, hide: function () { n && (n.remove(), n = null) } }) } } }) }(jQuery);
/*------------*/
!function (C) { C.extend(!0, window, { Slick: { CellSelectionModel: function (l) { var w, n, o = [], t = this, c = new Slick.CellRangeSelector({ selectionCss: { border: "2px solid black" } }), i = { selectActiveCell: !0 }; function g(e) { for (var l = [], n = 0; n < e.length; n++) { var o = e[n]; w.canCellBeSelected(o.fromRow, o.fromCell) && w.canCellBeSelected(o.toRow, o.toCell) && l.push(o) } return l } function h(e) { o = g(e), t.onSelectedRangesChanged.notify(o) } function f() { return o } function r(e, l) { if (w.getEditorLock().isActive()) return e.stopPropagation(), !1 } function s(e, l) { h([l.range]) } function a(e, l) { n.selectActiveCell && null != l.row && null != l.cell && h([new Slick.Range(l.row, l.cell)]) } function u(e) { var l, n, o = w.getActiveCell(); if (o && e.shiftKey && !e.ctrlKey && !e.altKey && (37 == e.which || 39 == e.which || 38 == e.which || 40 == e.which)) { (l = f()).length || l.push(new Slick.Range(o.row, o.cell)), (n = l.pop()).contains(o.row, o.cell) || (n = new Slick.Range(o.row, o.cell)); var t = n.toRow - n.fromRow, c = n.toCell - n.fromCell, i = o.row == n.fromRow ? 1 : -1, r = o.cell == n.fromCell ? 1 : -1; 37 == e.which ? c -= r : 39 == e.which ? c += r : 38 == e.which ? t -= i : 40 == e.which && (t += i); var s = new Slick.Range(o.row, o.cell, o.row + i * t, o.cell + r * c); if (g([s]).length) { l.push(s); var a = 0 < i ? s.toRow : s.fromRow, u = 0 < r ? s.toCell : s.fromCell; w.scrollRowIntoView(a), w.scrollCellIntoView(a, u) } else l.push(n); h(l), e.preventDefault(), e.stopPropagation() } } C.extend(this, { getSelectedRanges: f, setSelectedRanges: h, init: function (e) { n = C.extend(!0, {}, i, l), (w = e).getCanvasNode(), w.onActiveCellChanged.subscribe(a), w.onKeyDown.subscribe(u), e.registerPlugin(c), c.onCellRangeSelected.subscribe(s), c.onBeforeCellRangeSelected.subscribe(r) }, destroy: function () { w.onActiveCellChanged.unsubscribe(a), w.onKeyDown.unsubscribe(u), c.onCellRangeSelected.unsubscribe(s), c.onBeforeCellRangeSelected.unsubscribe(r), w.unregisterPlugin(c) }, onSelectedRangesChanged: new Slick.Event }) } } }) }(jQuery);